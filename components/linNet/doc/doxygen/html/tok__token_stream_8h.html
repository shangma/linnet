<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: tok_tokenStream.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tok__token_stream_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tok_tokenStream.h File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;types.h&quot;</code><br/>
</div>
<p><a href="tok__token_stream_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtok__token__t.html">tok_token_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtok__token_descriptor__t.html">tok_tokenDescriptor_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a45b048360c789ee610a202540443e606">TOK_COMPILE_FPRINTF_TOKEN</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a52c33fc2d735df6b04b648271855026a">TOK_HANDLE_TO_INVALID_TOKEN_STREAM</a>&#160;&#160;&#160;NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#ade300e4dd4ad5ab244e253f9aed08b16">TOK_UNINITIALIZED_TOKEN</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a1f709b6b8b0c12e5dcfa9a7e3e409f9d">TOK_USE_GET_TOKEN_TYPE</a>&#160;&#160;&#160;1</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#aeccefdc643b7256bc46af5a54e86403a">tok_tokenType_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtok__token__t.html">tok_token_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#aa66aa14425e08cbba9bb0a0e30f1becc">tok_token_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
tok_charInputStream_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a36a2bf82e47be1022b6b9e56b3878a46">tok_hCharInputStream_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef signed int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a> )(<a class="el" href="tok__token_stream_8h.html#a36a2bf82e47be1022b6b9e56b3878a46">tok_hCharInputStream_t</a> hCustomCharStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structtok__token_descriptor__t.html">tok_tokenDescriptor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a3aed679436965f642cb8e24e299aa083">tok_tokenDescriptor_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a7be11c0a4ee33bce0cc331157ec78a1f">tok_tokenDescriptorTable_t</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a4893baac80d8c3a4369c9e6e733abdb4">tok_tokenTypeEndOfLine</a> =  (tok_tokenType_t)'\n', 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ae28cf1f5340f5699e2fa0f8809d289c9">tok_tokenTypeEndOfFile</a> =  (tok_tokenType_t)EOF, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a0b62c2f1b7f58e7a04cc8e7e83861381">tok_tokenTypeUnidentified</a> =  256, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a660e7307bc8ecea8c068c27aa2db1727">tok_tokenTypeEmptyInitialized</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aaf60ffb9f30c3e55e1cecaad53c0ce22">tok_tokenTypeCommentOpener</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a6b94bddd914477de932b128e4efee453">tok_tokenTypeCommentTillEndOfLine</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aac146aa9808269e1757412f722bd237b">tok_tokenTypeIdentifier</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ae1268abf722fd4d84c5168835fedd28f">tok_tokenTypeInteger</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ac6fe64bd05a989c9077effd9014febdb">tok_tokenTypeFpn</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a0936935e1e74cd144746d0da8b000f23">tok_tokenTypeCharacter</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a0670bb353abaeb5f8b6826a0e2826045">tok_tokenTypeString</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a7a9b11f631fdd1403e7b2942abebacf4">tok_tokenType_lastTokenOfBuildInList</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a0135cefd1175cc5c50bd95dcd2c993b6">tok_tokenType_firstCustomToken</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> { <br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27a74217f59da415f2f2659e5d81b2151f1">tok_optionEolIsWhiteSpaceOnly</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27ac8857a4cf9e95ba16bbec36fec35aee6">tok_optionBinLiteral</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27adfcb0f290f68b4364322d181be5274a7">tok_optionSuffixMultipliers</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27a865e571ca85628fed5d7700755469159">tok_optionEscapeCharIsDollarSign</a>, 
<br/>
&#160;&#160;<a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27a5508fe3ff680cb47e6b9b9066ee99355">tok_optionStringsUseSingleQuotes</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#abff0f873238e261cf7f90cff1d02c037">tok_createTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const phTokenStream, char **const pErrorString, const char *const fileName, <a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a> hStream, const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a> customFctGetChar, const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const pCustomTokenDefinition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#af885a6c23c60d867f2b1848287b422aa">tok_deleteTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#aaa9a0a9c8c50295303866a2ac6752fdb">tok_setBoolOption</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> option, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a5ebbbd6e89026ec97adecd5e2ca296c2">tok_getErrorMsg</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, const char **const pErrMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#abf05149020c59eac572e33b614034a1d">tok_getLine</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a2d0f70b3c401fedd8730c15699392db1">tok_fprintfToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, FILE *hStream, const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8h.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Definition of global interface of module <a class="el" href="tok__token_stream_8c.html">tok_tokenStream.c</a></p>
<p>Copyright (C) 2014 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a45b048360c789ee610a202540443e606"></a><!-- doxytag: member="tok_tokenStream.h::TOK_COMPILE_FPRINTF_TOKEN" ref="a45b048360c789ee610a202540443e606" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOK_COMPILE_FPRINTF_TOKEN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Customization: Decide whether to compile a debug function, which prints the type and value of a token into a stdio stream.<br/>
 Set the value of the macro to either 0 or 1. </p>

</div>
</div>
<a class="anchor" id="a52c33fc2d735df6b04b648271855026a"></a><!-- doxytag: member="tok_tokenStream.h::TOK_HANDLE_TO_INVALID_TOKEN_STREAM" ref="a52c33fc2d735df6b04b648271855026a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOK_HANDLE_TO_INVALID_TOKEN_STREAM&#160;&#160;&#160;NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A constant initializer expression, that may be used as RHS of the definition of a token stream object. It's an invalid NULL handle, which must not be used at all. </p>

</div>
</div>
<a class="anchor" id="ade300e4dd4ad5ab244e253f9aed08b16"></a><!-- doxytag: member="tok_tokenStream.h::TOK_UNINITIALIZED_TOKEN" ref="ade300e4dd4ad5ab244e253f9aed08b16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOK_UNINITIALIZED_TOKEN</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ .type = <a class="code" href="tok__token_stream_8h.html#adf764cbdea00d65edcd07bb9953ad2b7a660e7307bc8ecea8c068c27aa2db1727">tok_tokenTypeEmptyInitialized</a>                     \
                                , .value = {.identifier = NULL}                             \
                                }
</pre></div><p>A compile time initializer expression, which can be used for objects of type <a class="el" href="structtok__token__t.html">tok_token_t</a>. </p>

</div>
</div>
<a class="anchor" id="a1f709b6b8b0c12e5dcfa9a7e3e409f9d"></a><!-- doxytag: member="tok_tokenStream.h::TOK_USE_GET_TOKEN_TYPE" ref="a1f709b6b8b0c12e5dcfa9a7e3e409f9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOK_USE_GET_TOKEN_TYPE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This switch decides whether the function tok_getTokenType is compiled. Normally, this function will be used for debug and testing purpose only but is not required in the production code. Therefore, setting the macro can be done from outside, e.g. controlled by the makefile. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function tok_getTokenType makes a switch/case of the different known token types. As these depent (partly) on the compile time application configuration the function implementation may be subject to application specific modifications. </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aeccefdc643b7256bc46af5a54e86403a"></a><!-- doxytag: member="tok_tokenStream.h::tok_tokenType_t" ref="aeccefdc643b7256bc46af5a54e86403a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed int <a class="el" href="tok__token_stream_8h.html#aeccefdc643b7256bc46af5a54e86403a">tok_tokenType_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Basically, the type of a recognized token is an enumeration. In order to let this enumeration be extendable at different code locations we implement it not as a true enum but as an integer, which we will only assign true enum values to. We use the signed type as the constant EOF from the stdio library is an important example of a token type. </p>

</div>
</div>
<a class="anchor" id="aa66aa14425e08cbba9bb0a0e30f1becc"></a><!-- doxytag: member="tok_tokenStream.h::tok_token_t" ref="aa66aa14425e08cbba9bb0a0e30f1becc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtok__token__t.html">tok_token_t</a>  <a class="el" href="structtok__token__t.html">tok_token_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The recognized lexical atom is returned by the token stream (function <em>tok_getNextToken</em>) as an object of this structure. The intended use case is to have a single instance of this type and to reuse it throughout the complete tokenizing process. In each call of function <em>tok_getNextToken</em> it'll be filled with the information describing the next lexical atom found in the input stream.<br/>
 Caution, an object of this type is both, input and output to function <em>tok_getNextToken</em>. If the token is of kind integer or string, then its value is the pointer to a malloc allocated string. This pointer - if not NULL - is freed on entry into the function, in order to make room for the value of the next token. Therefore, prior to the very first invocation of function <em>tok_getNextToken</em> the object needs to be properly initialize. The combination of kind integer or string with a non NULL pointer value would cause a severe error by freeing this seeming heap object. To avoid this problem, always use macro <a class="el" href="tok__token_stream_8h.html#ade300e4dd4ad5ab244e253f9aed08b16">TOK_UNINITIALIZED_TOKEN</a> as a compile time initializer expression for instances of this type. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="tok__token_stream_8h.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken(tok_hTokenStream_t, tok_token_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6d0f0460027befdf25f37788ddc051f"></a><!-- doxytag: member="tok_tokenStream.h::tok_hTokenStream_t" ref="ac6d0f0460027befdf25f37788ddc051f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a>* <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The token stream is defined as an anonymous struct. Here, we only defined the handle of an object of this class. </p>

</div>
</div>
<a class="anchor" id="a36a2bf82e47be1022b6b9e56b3878a46"></a><!-- doxytag: member="tok_tokenStream.h::tok_hCharInputStream_t" ref="a36a2bf82e47be1022b6b9e56b3878a46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct tok_charInputStream_t* <a class="el" href="tok__token_stream_8h.html#a36a2bf82e47be1022b6b9e56b3878a46">tok_hCharInputStream_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The client of the scanner may use a file from stdio as input and use a built-in read function or he might specify his own character read function. In the latter case he will define a character input function f as:<br/>
 signed int f(tok_hCharInputStream_t hStream)<br/>
 The type of his stream is opaque to this scanner implementation, the client will define the type in close relation to his character input function. </p>

</div>
</div>
<a class="anchor" id="a71610e828ac97accc8bd63debb1dbb42"></a><!-- doxytag: member="tok_tokenStream.h::tok_customFctGetChar" ref="a71610e828ac97accc8bd63debb1dbb42" args=")(tok_hCharInputStream_t hCustomCharStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef signed int(* <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a>)(<a class="el" href="tok__token_stream_8h.html#a36a2bf82e47be1022b6b9e56b3878a46">tok_hCharInputStream_t</a> hCustomCharStream)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The custom character stream has an only mandatory function in its interface. This is the function to read the next character from that stream. The function takes the stream handle type as input. Given the possibility to hide any kind of data structure behind the handle type it should be possible to implement any idea of an input stream.<br/>
 Not apparent in the interface definition but essential: The end of input is signaled by returning the constant EOF (defined by the stdio library) once and also over and over if the function should continuously be invoked.<br/>
 Stream errors can npt be reported. If an error appears the custom shall behave as if it was the end of the input. </p>

</div>
</div>
<a class="anchor" id="a3aed679436965f642cb8e24e299aa083"></a><!-- doxytag: member="tok_tokenStream.h::tok_tokenDescriptor_t" ref="a3aed679436965f642cb8e24e299aa083" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtok__token_descriptor__t.html">tok_tokenDescriptor_t</a>  <a class="el" href="structtok__token_descriptor__t.html">tok_tokenDescriptor_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Internally, the scanner implementation uses a table, that relates recognized, specific character sequences to an integer value, which is returned as token type. The client may define his own, specific character sequences or symbols or tokens by passing an extention of the built-in symbol definitions to the scanner. The elements of this extended syntax definition have this type.<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Identical symbols are not supported, but currently the implementation doesn't double-check for doubly defined smbols. </dd>
<dd>
Using identical token values (or <em>type</em>) is valid and supported. Different character sequences would be reported in a transparent way to the client as same token. One could e.g. define the <em>symbol</em> ";" as <em>type</em> <em>tok_tokenTypeEndOfLine</em>, in which case the semicolon would have the same meaning to the client parser as an end of line character. </dd></dl>

</div>
</div>
<a class="anchor" id="a7be11c0a4ee33bce0cc331157ec78a1f"></a><!-- doxytag: member="tok_tokenStream.h::tok_tokenDescriptorTable_t" ref="a7be11c0a4ee33bce0cc331157ec78a1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a>  <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See other type <a class="el" href="structtok__token_descriptor__t.html">tok_tokenDescriptor_t</a>: Here we have the complete token definition table, which contains all client specified symbols and their token values. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7"></a><!-- doxytag: member="tok_tokenStream.h::@1" ref="adf764cbdea00d65edcd07bb9953ad2b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration lists the hard coded, not application dependent types of symbols, like string constants, integer and floating point number literals.<br/>
 The enumeration starts with the numeric value 256. The scanner will return single characters, which do not belong to a known token type as themselves: These characters are used as the them decribing token type at the same time.<br/>
 The list ends with a named value, that actually is not a token type but can be used to continue the enumeration at another code location. This is used to define the application dependent token definitions. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The token types <em>tok_tokenTypeCommentOpener</em> and <em>tok_tokenTypeCommentTillEndOfLine</em> are used internally only. If a such a token is recognized by the tokenizer it won't return it to the client but will silently discrad it and read the next token from the input stream. The first non-comment token is returned. </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a4893baac80d8c3a4369c9e6e733abdb4"></a><!-- doxytag: member="tok_tokenTypeEndOfLine" ref="adf764cbdea00d65edcd07bb9953ad2b7a4893baac80d8c3a4369c9e6e733abdb4" args="" -->tok_tokenTypeEndOfLine</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7ae28cf1f5340f5699e2fa0f8809d289c9"></a><!-- doxytag: member="tok_tokenTypeEndOfFile" ref="adf764cbdea00d65edcd07bb9953ad2b7ae28cf1f5340f5699e2fa0f8809d289c9" args="" -->tok_tokenTypeEndOfFile</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a0b62c2f1b7f58e7a04cc8e7e83861381"></a><!-- doxytag: member="tok_tokenTypeUnidentified" ref="adf764cbdea00d65edcd07bb9953ad2b7a0b62c2f1b7f58e7a04cc8e7e83861381" args="" -->tok_tokenTypeUnidentified</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a660e7307bc8ecea8c068c27aa2db1727"></a><!-- doxytag: member="tok_tokenTypeEmptyInitialized" ref="adf764cbdea00d65edcd07bb9953ad2b7a660e7307bc8ecea8c068c27aa2db1727" args="" -->tok_tokenTypeEmptyInitialized</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7aaf60ffb9f30c3e55e1cecaad53c0ce22"></a><!-- doxytag: member="tok_tokenTypeCommentOpener" ref="adf764cbdea00d65edcd07bb9953ad2b7aaf60ffb9f30c3e55e1cecaad53c0ce22" args="" -->tok_tokenTypeCommentOpener</em>&nbsp;</td><td>
<p>Only used internally. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a6b94bddd914477de932b128e4efee453"></a><!-- doxytag: member="tok_tokenTypeCommentTillEndOfLine" ref="adf764cbdea00d65edcd07bb9953ad2b7a6b94bddd914477de932b128e4efee453" args="" -->tok_tokenTypeCommentTillEndOfLine</em>&nbsp;</td><td>
<p>Only used internally. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7aac146aa9808269e1757412f722bd237b"></a><!-- doxytag: member="tok_tokenTypeIdentifier" ref="adf764cbdea00d65edcd07bb9953ad2b7aac146aa9808269e1757412f722bd237b" args="" -->tok_tokenTypeIdentifier</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7ae1268abf722fd4d84c5168835fedd28f"></a><!-- doxytag: member="tok_tokenTypeInteger" ref="adf764cbdea00d65edcd07bb9953ad2b7ae1268abf722fd4d84c5168835fedd28f" args="" -->tok_tokenTypeInteger</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7ac6fe64bd05a989c9077effd9014febdb"></a><!-- doxytag: member="tok_tokenTypeFpn" ref="adf764cbdea00d65edcd07bb9953ad2b7ac6fe64bd05a989c9077effd9014febdb" args="" -->tok_tokenTypeFpn</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a0936935e1e74cd144746d0da8b000f23"></a><!-- doxytag: member="tok_tokenTypeCharacter" ref="adf764cbdea00d65edcd07bb9953ad2b7a0936935e1e74cd144746d0da8b000f23" args="" -->tok_tokenTypeCharacter</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a0670bb353abaeb5f8b6826a0e2826045"></a><!-- doxytag: member="tok_tokenTypeString" ref="adf764cbdea00d65edcd07bb9953ad2b7a0670bb353abaeb5f8b6826a0e2826045" args="" -->tok_tokenTypeString</em>&nbsp;</td><td>
<p>Custom token values must be greater than this one. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a7a9b11f631fdd1403e7b2942abebacf4"></a><!-- doxytag: member="tok_tokenType_lastTokenOfBuildInList" ref="adf764cbdea00d65edcd07bb9953ad2b7a7a9b11f631fdd1403e7b2942abebacf4" args="" -->tok_tokenType_lastTokenOfBuildInList</em>&nbsp;</td><td>
<p>Client code should use this value to initialize its first custom token vlaue. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7a0135cefd1175cc5c50bd95dcd2c993b6"></a><!-- doxytag: member="tok_tokenType_firstCustomToken" ref="adf764cbdea00d65edcd07bb9953ad2b7a0135cefd1175cc5c50bd95dcd2c993b6" args="" -->tok_tokenType_firstCustomToken</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27"></a><!-- doxytag: member="tok_tokenStream.h::tok_syntaxOption_t" ref="a86a88d74d57151e6ef267b161fa1fa27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some syntax constructs of the tokenizer are optional, i.e. they can be switched on or off in order to customize the behavior.<br/>
 Use the values of this enumeration with method tok_setBoolOption to set the options appropriately. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27a74217f59da415f2f2659e5d81b2151f1"></a><!-- doxytag: member="tok_optionEolIsWhiteSpaceOnly" ref="a86a88d74d57151e6ef267b161fa1fa27a74217f59da415f2f2659e5d81b2151f1" args="" -->tok_optionEolIsWhiteSpaceOnly</em>&nbsp;</td><td>
<p>By default, the end of line is a recognized token. This can be switched off using this option.<br/>
 There's an important interrelation with string tokens: As in C, if string literals are separated by white space only, then they are seen as one string literal. If the EOL character is not seen as white space, then string literal melting becomes rather useless as it would take place only with string literals on the same line. Binary number literal are supported. They begin with a %, immediately followed by a sequence of 1 and 0 digits. Binary numbers are limited to positive integers. Default is false. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27ac8857a4cf9e95ba16bbec36fec35aee6"></a><!-- doxytag: member="tok_optionBinLiteral" ref="a86a88d74d57151e6ef267b161fa1fa27ac8857a4cf9e95ba16bbec36fec35aee6" args="" -->tok_optionBinLiteral</em>&nbsp;</td><td>
<p>Floating point numbers can have a one-character exponent, e.g. 1k meaning 1e3 or 23.4u meaning 23.4e-6. Default is false.<br/>
 The table of supported suffixes has been taken from <a href="http://searchstorage.techtarget.com/definition/Kilo-mega-giga-tera-peta-and-all-that,">http://searchstorage.techtarget.com/definition/Kilo-mega-giga-tera-peta-and-all-that,</a> visted on Feb 9, 2014. The suffix E for 10^18 had to be changed to X because of the conflict with the normal exponential form of a floating point number:<br/>
 yocto (10^-24): use suffix y<br/>
 zepto (10^-21): use suffix z<br/>
 atto (10^-18): use suffix a<br/>
 femto (10^-15): use suffix f<br/>
 pico (10^-12): use suffix p<br/>
 nano (10^-9) : use suffix n<br/>
 micro (10^-6) : use suffix u<br/>
 milli (10^-3) : use suffix m<br/>
 centi (10^-2) : use suffix c<br/>
 deci (10^-1) : use suffix d<br/>
 deka (10^1) : use suffix D<br/>
 hecto (10^2) : use suffix h<br/>
 kilo (10^3) : use suffix k<br/>
 mega (10^6) : use suffix M<br/>
 giga (10^9) : use suffix G<br/>
 tera (10^12) : use suffix T<br/>
 peta (10^15) : use suffix P<br/>
 exa (10^18) : use suffix X (instead of E)<br/>
 zetta (10^21) : use suffix Z<br/>
 yotta (10^24) : use suffix Y </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27adfcb0f290f68b4364322d181be5274a7"></a><!-- doxytag: member="tok_optionSuffixMultipliers" ref="a86a88d74d57151e6ef267b161fa1fa27adfcb0f290f68b4364322d181be5274a7" args="" -->tok_optionSuffixMultipliers</em>&nbsp;</td><td>
<p>The escape character for special characters in strings can be switched from the standard backslash to the alternative $. This is considered useful in Windows environments, where starings with the backslash as an ordinary character are quite common as file paths. Default is the backslash. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27a865e571ca85628fed5d7700755469159"></a><!-- doxytag: member="tok_optionEscapeCharIsDollarSign" ref="a86a88d74d57151e6ef267b161fa1fa27a865e571ca85628fed5d7700755469159" args="" -->tok_optionEscapeCharIsDollarSign</em>&nbsp;</td><td>
<p>Some environments define strings as enclosed in single quotes. If this option is defined then no character constants are defined (which look as in C, also in single quotes); now they are recognized and returned as strings of length one. Default is to use double quotes. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a86a88d74d57151e6ef267b161fa1fa27a5508fe3ff680cb47e6b9b9066ee99355"></a><!-- doxytag: member="tok_optionStringsUseSingleQuotes" ref="a86a88d74d57151e6ef267b161fa1fa27a5508fe3ff680cb47e6b9b9066ee99355" args="" -->tok_optionStringsUseSingleQuotes</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abff0f873238e261cf7f90cff1d02c037"></a><!-- doxytag: member="tok_tokenStream.h::tok_createTokenStream" ref="abff0f873238e261cf7f90cff1d02c037" args="(tok_hTokenStream_t *const phTokenStream, char **const pErrorString, const char *const fileName, tok_hStream_t hStream, const tok_customFctGetChar customFctGetChar, const tok_tokenDescriptorTable_t *const pCustomTokenDefinition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_createTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>phTokenStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **const&#160;</td>
          <td class="paramname"><em>pErrorString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a>&#160;</td>
          <td class="paramname"><em>customFctGetChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const&#160;</td>
          <td class="paramname"><em>pCustomTokenDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A token stream object is created.</p>
<p>A token stream object is created. It is associated with either a stdio stream or with any kind of custom character stream. The created object can be used to parse the input from that stream into a sequence of lexcical atoms or tokens. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True, if the stream could be opened successfully, or false otherwise. The only other operation, which is permitted to be applied to the returned object, is tok_deleteTokenStream if the function returns false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">phTokenStream</td><td>The handle to the created object is placed into <em>phTokenStream</em>. </td></tr>
    <tr><td class="paramname">pErrorString</td><td>A pointer to a string variable owned by the caller. If an error appears, then a malloc allocated read-only string is placed into this variable. Normally NULL is returned in * <em>pErrorString</em>.<br/>
 Caution: The caller is in charge to free the string after use. </td></tr>
    <tr><td class="paramname">fileName</td><td>The name of the file (or character stream), which is parsed. Mainly used for logging. Only, if hFile is NULL then it really needs to be the name of (and path to) an existing file. This file will then be opened for read access and be parsed.<br/>
 If there's no reasonable name (e.g. in case of custom character input) then pass NULL or the empty string. </td></tr>
    <tr><td class="paramname">hStream</td><td>The parsed stream object. Either a stream from the stdio library or a custom stream of unknown type.<br/>
 If parameter <em>customGetChar</em> is not NULL, then <em>hStream</em> is interpreted as handle of the custom stream. Otherwise it is interpreted as stdio stream (FILE*). In the latter case NULL may be passed: A file <em>fileName</em> will be opened as stdio stream and will be parsed then. </td></tr>
    <tr><td class="paramname">customFctGetChar</td><td>The pointer to a custom character input function, which reads a single character from a custom stream of type tok_hCharInputStream_t. Pass NULL if the stdio input should be used. </td></tr>
    <tr><td class="paramname">pCustomTokenDefinition</td><td>The customer provided extension of the internal symbol definitions. Basically a table associating symbols with token values. The tokenizer will look for the symbols in the input stream and return the associated token value if finds one. Additionally the symbols are specified, which mark beginning and end of comments.<br/>
 Pass NULL if no custom symbols are needed.<br/>
 The constructor makes a deep copy of the passed objects. All contained strings can be deleted after return from the constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af885a6c23c60d867f2b1848287b422aa"></a><!-- doxytag: member="tok_tokenStream.h::tok_deleteTokenStream" ref="af885a6c23c60d867f2b1848287b422aa" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_deleteTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a token stream object as created by tok_createTokenStream.</p>
<p>Delete a token stream object as created by tok_createTokenStream. A possibly open stdio stream is closed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The handle to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa9a0a9c8c50295303866a2ac6752fdb"></a><!-- doxytag: member="tok_tokenStream.h::tok_setBoolOption" ref="aaa9a0a9c8c50295303866a2ac6752fdb" args="(tok_hTokenStream_t hTStream, tok_syntaxOption_t option, boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_setBoolOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a Boolean option of the tokenizer.</p>
<p>Set an option of the tokenizer. Do this after object creation but prior to the first invocation of boolean <a class="el" href="tok__token_stream_8h.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken(tok_hTokenStream_t, tok_token_t * const)</a>.<br/>
 See enumeration <em>tok_syntaxOption_t</em> for the available options. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">option</td><td>The selected option. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ebbbd6e89026ec97adecd5e2ca296c2"></a><!-- doxytag: member="tok_tokenStream.h::tok_getErrorMsg" ref="a5ebbbd6e89026ec97adecd5e2ca296c2" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tok_getErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current, last recently set error message.</p>
<p>Get the current, last recently set error message. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get a read-only string. The returned pointer is only valid until the next invocation of any method on the token stream object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="tok__token_stream_8h.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError(tok_hTokenStream_t, const char ** const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16729b7f12f3a293663c6039b6d3979a"></a><!-- doxytag: member="tok_tokenStream.h::tok_resetError" ref="a16729b7f12f3a293663c6039b6d3979a" args="(tok_hTokenStream_t hTStream, const char **const pErrMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_resetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>pErrMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset error in order to proceed scanning the input.</p>
<p>Acknwledge an error. Most often, a parser will try to continue the process even after an error. If it reported an error from the tokenizer, it should explicitly reset the error in the token stream prior to calling tok_getNextToken the next time. Otherwise it looses the chance to see new errors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The cleared error status is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">pErrMsg</td><td>If not NULL the current (now cleared) error message is placed into * <em>pErrMsg</em>. The returned value is the pointer to a temporary read only string. It is valid only until the next call of whatever method of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>const char *tok_getErrorMsg(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="abf05149020c59eac572e33b614034a1d"></a><!-- doxytag: member="tok_tokenStream.h::tok_getLine" ref="abf05149020c59eac572e33b614034a1d" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tok_getLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current line number of the input stream.</p>
<p>Get the current line number of the input stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the line number. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d0f70b3c401fedd8730c15699392db1"></a><!-- doxytag: member="tok_tokenStream.h::tok_fprintfToken" ref="a2d0f70b3c401fedd8730c15699392db1" args="(tok_hTokenStream_t hTStream, FILE *hStream, const tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_fprintfToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug function (compiled only on demand, see <a class="el" href="tok__token_stream_8h.html#a45b048360c789ee610a202540443e606">TOK_COMPILE_FPRINTF_TOKEN</a>): The type and value of a token is printed into a stdio stream.</p>
<p>Debug function (compiled only on demand, see <a class="el" href="tok__token_stream_8h.html#a45b048360c789ee610a202540443e606">TOK_COMPILE_FPRINTF_TOKEN</a>):<br/>
 The type and value of a token is printed into a stdio stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">hStream</td><td>A handle to a stdio file with write access in text mode. </td></tr>
    <tr><td class="paramname">pToken</td><td>The token is passed in by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6265f294842ee4d9e2c4fa2909e47a8f"></a><!-- doxytag: member="tok_tokenStream.h::tok_getNextToken" ref="a6265f294842ee4d9e2c4fa2909e47a8f" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_getNextToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Main operation on a token stream: Read the next token (or lexical atom) from the input.</p>
<p>Main operation on a token stream: Read the next token (or lexical atom) from the input stream.<br/>
 The end-of-file is always defined as a token. The client of this class will call this method in a loop until it gets the token EOF. Further calls are permitted but will always return EOF again. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Recognizing tokens in read character sequences can fail. If the next characters in the stream do not form any defined token, then the function returns false. The client knows that there is a syntax error. It can request the error message by const char *tok_getErrorMsg(tok_hTokenStream_t). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object to read from. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tok__token_stream_8h.html">tok_tokenStream.h</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
