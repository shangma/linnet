<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: les_linearEquationSystem.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('les__linear_equation_system_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>les_linearEquationSystem.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;smalloc.h&quot;</code><br/>
<code>#include &quot;log_logger.h&quot;</code><br/>
<code>#include &quot;mem_memoryManager.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="pci__parser_circuit_8h_source.html">pci_parserCircuit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tbv__table_of_variables_8h_source.html">tbv_tableOfVariables.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8h_source.html">coe_coefficient.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8inline_interface_8h_source.html">coe_coefficient.inlineInterface.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="les__linear_equation_system_8h_source.html">les_linearEquationSystem.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a7c7d0957904173d6159d538259e18f15">MAX_SIZE_OF_SYMBOL_PREFIX</a>&#160;&#160;&#160;(10+1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#aeab32e55bc18973faef7b1777306ef7c">SYMBOL_PREFIX_VOLTAGE</a>&#160;&#160;&#160;&quot;U_&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ad26d4a00c38a73953261a766cb588f3d">SYMBOL_PREFIX_CURRENT</a>&#160;&#160;&#160;&quot;I_&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#af102b2826266d5b7f9ffd464fe8313c4">WARN_IF_UNFREED_MEM</a>&#160;&#160;&#160;true</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a2627c73f30a30e51827a89733b8e7a96">deleteNetwork</a> (network_t *const pNetwork)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a65ebc912fe0c34d2627bc5d2dad64045">lookForSubNetByNode</a> (const network_t *const pNetwork, unsigned int idxNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a3dee82a3c211bae32d6f4f6be9f8a931">concatNodeLists</a> (<a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> **const ppHeadOfMajorList, <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> **const ppHeadOfMinorList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ab34f6994ed2b51c021664b9b054d9839">logNetworkTopology</a> (const network_t *const pNetwork)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#aa551d6107b6f65bbebddd5dce9fa8d4c">analyseNetworkTopology</a> (network_t **const ppNetwork, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pCircuitNetList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#aff0ea2e30ae63b69e8167dabbc5e9254">findNodeGnd</a> (unsigned int *const pIdxGroundNode, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pCircuitNetList, const <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> *const pHeadOfNodeList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a1de0c2cddbff3f0943a9f00f30d6573e">createNameOfUnknown</a> (char name[], unsigned int maxLen, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isVoltage, const char *const userObject)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a1a75a1301e67ae2fb8d60199a43d9284">determineReqVariables</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> **const ppTableOfVars, const network_t *const pNetwork)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ae02a9f1e602a61c03a621cefa596377c">addSrcUConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ac2e984d1032e607c3cd5a5b889f7e515">addSrcIConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ab5320557b6c76b47b226935b90aaa0f3">addPassiveDeviceConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a4c26718fad0c3f868f3d6debf8f8acb1">addOpAmpConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a02cc96ff59e244c57fb64207d8522dbc">addCurrentProbeConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ab231a69f4d29015e9e8540f35a09196d">addSrcUByUConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a7d1383dac859561bae4cbe26cd6a5fb5">addSrcUByIConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a9252c91eb7fce311f4416097e9e21321">addSrcIByUConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a485fd35ce69b91a773897c3e8d59b44f">addSrcIByIConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a3dbc03520cc2c8fc31acb9da572e9e51">addDeviceConditions</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const A, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, unsigned int idxDev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#ade6aacc477a37768f8df3ff55a5492ed">les_initModule</a> (<a class="el" href="structlog__logger__t.html">log_hLogger_t</a> hGlobalLogger)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a1a4234d54652d74d7ab137c4377db99d">les_shutdownModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a3e36303dc29cc0eb83a78f6a98719d34">les_createLES</a> (<a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> **const ppLES, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pCircuitNetList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#af8454e4a85aec8981f3dd267da01b0db">les_deleteLES</a> (<a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *pLES)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a0ad3f23596ab4eb95fbbd2831cb888e6">les_getNoVariables</a> (const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES, unsigned int *const pNoKnowns, unsigned int *const pNoUnknowns, unsigned int *const pNoConstants)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a3fbbf87214e42ce9a29b490b82d935d2">les_getTableOfVariables</a> (const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a4c2df3ba31781c948f3d44710bcfab70">les_getTableOfUnknowns</a> (const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES, unsigned int *const pNoUnknowns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a09c8dedabdd758472dfac13751e5b522">les_setupLES</a> (<a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES, const char *const nameOfUnknown)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem__memory_manager_8h.html#aeacb2c05257cf2640d30be458abb4f99">mem_hHeap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="les__linear_equation_system_8c.html#a786f2d8bb2b0f95e8d943cd1c401db92">_hMemMgrSubNet</a> = MEM_HANDLE_INVALID_HEAP</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Analyse the parsed network structure and create the linear equation system.</p>
<p>Copyright (C) 2013-2014 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7c7d0957904173d6159d538259e18f15"></a><!-- doxytag: member="les_linearEquationSystem.c::MAX_SIZE_OF_SYMBOL_PREFIX" ref="a7c7d0957904173d6159d538259e18f15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_SIZE_OF_SYMBOL_PREFIX&#160;&#160;&#160;(10+1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Symbols introduced by the internal algorithms are derived from known, user defined names by adding a pre- or suffix. The required buffer size for the derived names is the length of the base name plus the value of this define. </p>

</div>
</div>
<a class="anchor" id="aeab32e55bc18973faef7b1777306ef7c"></a><!-- doxytag: member="les_linearEquationSystem.c::SYMBOL_PREFIX_VOLTAGE" ref="aeab32e55bc18973faef7b1777306ef7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYMBOL_PREFIX_VOLTAGE&#160;&#160;&#160;&quot;U_&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The prefix used to derive the name of an unknown voltage from a node's name.<br/>
 Truncation of names is safely avoided if the prefix defined here is no longer than <a class="el" href="les__linear_equation_system_8c.html#a7c7d0957904173d6159d538259e18f15">MAX_SIZE_OF_SYMBOL_PREFIX</a>-1. </p>

</div>
</div>
<a class="anchor" id="ad26d4a00c38a73953261a766cb588f3d"></a><!-- doxytag: member="les_linearEquationSystem.c::SYMBOL_PREFIX_CURRENT" ref="ad26d4a00c38a73953261a766cb588f3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYMBOL_PREFIX_CURRENT&#160;&#160;&#160;&quot;I_&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The prefix used to derive the name of an unknown current from a device name.<br/>
 Truncation of names is safely avoided if the prefix defined here is no longer than <a class="el" href="les__linear_equation_system_8c.html#a7c7d0957904173d6159d538259e18f15">MAX_SIZE_OF_SYMBOL_PREFIX</a>-1. </p>

</div>
</div>
<a class="anchor" id="af102b2826266d5b7f9ffd464fe8313c4"></a><!-- doxytag: member="les_linearEquationSystem.c::WARN_IF_UNFREED_MEM" ref="af102b2826266d5b7f9ffd464fe8313c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WARN_IF_UNFREED_MEM&#160;&#160;&#160;true</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa54ac92794ba27d3e345cdb13007bb4b"></a><!-- doxytag: member="les_linearEquationSystem.c::networkNodeRef_t" ref="aa54ac92794ba27d3e345cdb13007bb4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a>  <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Part of the internal network representation: An element of the linked list of network nodes. </p>

</div>
</div>
<a class="anchor" id="a90c8b47877de2d8cfc530315f5d42140"></a><!-- doxytag: member="les_linearEquationSystem.c::subNetwork_t" ref="a90c8b47877de2d8cfc530315f5d42140" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a>  <a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Part of the internal network representation: An element of the linked list of unconnected (sub-)networks. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2627c73f30a30e51827a89733b8e7a96"></a><!-- doxytag: member="les_linearEquationSystem.c::deleteNetwork" ref="a2627c73f30a30e51827a89733b8e7a96" args="(network_t *const pNetwork)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void deleteNetwork </td>
          <td>(</td>
          <td class="paramtype">network_t *const&#160;</td>
          <td class="paramname"><em>pNetwork</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free all data allocated in the data structure representing the network graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNetwork</td><td>The pointer to the data structure to de-allocate. No action if this is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65ebc912fe0c34d2627bc5d2dad64045"></a><!-- doxytag: member="les_linearEquationSystem.c::lookForSubNetByNode" ref="a65ebc912fe0c34d2627bc5d2dad64045" args="(const network_t *const pNetwork, unsigned int idxNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="les__linear_equation_system_8c.html#a90c8b47877de2d8cfc530315f5d42140">subNetwork_t</a>* lookForSubNetByNode </td>
          <td>(</td>
          <td class="paramtype">const network_t *const&#160;</td>
          <td class="paramname"><em>pNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Iterate through a list of sub-networks and look for the first one, which contains a given node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the sub-network that contains the node or NULL if no such sub-network exists. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNetwork</td><td>A pointer to the first network object in the linked list of such. </td></tr>
    <tr><td class="paramname">idxNode</td><td>The node to look for is identified by index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Throughout the entire run of the algorithm there will never be a node in more than one sub-network's node list. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dee82a3c211bae32d6f4f6be9f8a931"></a><!-- doxytag: member="les_linearEquationSystem.c::concatNodeLists" ref="a3dee82a3c211bae32d6f4f6be9f8a931" args="(networkNodeRef_t **const ppHeadOfMajorList, networkNodeRef_t **const ppHeadOfMinorList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void concatNodeLists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> **const&#160;</td>
          <td class="paramname"><em>ppHeadOfMajorList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> **const&#160;</td>
          <td class="paramname"><em>ppHeadOfMinorList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Combine two node lists to a single one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ppHeadOfMajorList</td><td>A pointer to the pointer variable that points to the head of the first node list. The other list will be appended to this list and after return <em>*ppHeadOfMajorList</em> will point to the combined list. </td></tr>
    <tr><td class="paramname">ppHeadOfMinorList</td><td>A pointer to the pointer variable that points to the head of the second node list. This list is transfered to the end of the major list and the pointer to the head of the second list is set to NULL, i.e. <em>*ppHeadOfMinorList</em> = NULL. After return there won't be doubled references to the elements of the minor list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab34f6994ed2b51c021664b9b054d9839"></a><!-- doxytag: member="les_linearEquationSystem.c::logNetworkTopology" ref="ab34f6994ed2b51c021664b9b054d9839" args="(const network_t *const pNetwork)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void logNetworkTopology </td>
          <td>(</td>
          <td class="paramtype">const network_t *const&#160;</td>
          <td class="paramname"><em>pNetwork</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Present the result of the network topology struture in the log. The user should find a representation equivalent to the node list in his input circuit file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNetwork</td><td>The network data structure to present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa551d6107b6f65bbebddd5dce9fa8d4c"></a><!-- doxytag: member="les_linearEquationSystem.c::analyseNetworkTopology" ref="aa551d6107b6f65bbebddd5dce9fa8d4c" args="(network_t **const ppNetwork, const pci_circuit_t *const pCircuitNetList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> analyseNetworkTopology </td>
          <td>(</td>
          <td class="paramtype">network_t **const&#160;</td>
          <td class="paramname"><em>ppNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pCircuitNetList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Iterate through the parsing result and find out how the nodes in use are interconnected. Shape a new derived data structure, that represents the network in a way that permits to setup the linear equation system.<br/>
 The returned object needs to be deleted after usage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if function succeeds. A network object has been created and no connectivity error has been recognized. <em>false</em> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ppNetwork</td><td>The pointer to the built-up data structure, that represents the network structure is returned in * <em>ppNetwork</em>.<br/>
 If the function returns false then * <em>ppNetwork</em> will contain NULL. </td></tr>
    <tr><td class="paramname">pCircuitNetList</td><td>The net list as returned by the parser. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="les__linear_equation_system_8c.html#a2627c73f30a30e51827a89733b8e7a96">deleteNetwork(network_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff0ea2e30ae63b69e8167dabbc5e9254"></a><!-- doxytag: member="les_linearEquationSystem.c::findNodeGnd" ref="aff0ea2e30ae63b69e8167dabbc5e9254" args="(unsigned int *const pIdxGroundNode, const pci_circuit_t *const pCircuitNetList, const networkNodeRef_t *const pHeadOfNodeList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> findNodeGnd </td>
          <td>(</td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pIdxGroundNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pCircuitNetList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="les__linear_equation_system_8c.html#aa54ac92794ba27d3e345cdb13007bb4b">networkNodeRef_t</a> *const&#160;</td>
          <td class="paramname"><em>pHeadOfNodeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select one node out of all nodes of a sub-grapgh, which shall have voltage null. Basically any node can be defined to play this roll. However, typical use cases will define a node to have a name like gnd or ground. If we can find such a node, we will use it otherwise we (arbitrarily) use the first node.<br/>
 There's one hard condition to be fulfillied: The ouput of the op-amp must not be connected to the ground node; this is because of the way the op-amp is expressed as a linear equation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if a suitable ground node could be determined or <em>false</em> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIdxGroundNode</td><td>The index of the ground node pointing into the array of nodes in the net list representing the circuit is returned as * <em>pIdxGroundNode</em>.<br/>
 If no suitable ground node can be found then PCI_NULL_NODE is returned. </td></tr>
    <tr><td class="paramname">pCircuitNetList</td><td>The net list as returned by the input file parser. </td></tr>
    <tr><td class="paramname">pHeadOfNodeList</td><td>The list of nodes belonging to the sub-graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1de0c2cddbff3f0943a9f00f30d6573e"></a><!-- doxytag: member="les_linearEquationSystem.c::createNameOfUnknown" ref="a1de0c2cddbff3f0943a9f00f30d6573e" args="(char name[], unsigned int maxLen, boolean isVoltage, const char *const userObject)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void createNameOfUnknown </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>name</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>isVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>userObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The user input file doesn't define the name of the unknowns of the LES, but the meaning of the unknowns is closely related to the user specified elements. Therefore we have a function, that derives name sfor unknowns from the user specified elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The character which to place the generate name in. </td></tr>
    <tr><td class="paramname">maxLen</td><td>The maximum generated string length. name is as least one character larger. </td></tr>
    <tr><td class="paramname">isVoltage</td><td>The unknowns are either voltages or currents and the name depends on the physical quantity. </td></tr>
    <tr><td class="paramname">userObject</td><td>The name of the user specified object the unknown is related to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a75a1301e67ae2fb8d60199a43d9284"></a><!-- doxytag: member="les_linearEquationSystem.c::determineReqVariables" ref="a1a75a1301e67ae2fb8d60199a43d9284" args="(tbv_tableOfVariables_t **const ppTableOfVars, const network_t *const pNetwork)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> determineReqVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> **const&#160;</td>
          <td class="paramname"><em>ppTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const network_t *const&#160;</td>
          <td class="paramname"><em>pNetwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find out how many and which known and unknown variables and how many constants are required in the LES describing the network. This is pass one of making the LES. After return, we have a data structure describing all variables and constants in use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function will indicate failure by return value <em>false</em>, e.g. if the permitted number of constants or knowns or unknowns is exceeded. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ppTableOfVars</td><td>The reference to the table of variables is passed. The table is created at the beginning and filled with all knowns, unknowns and constants found in the network. </td></tr>
    <tr><td class="paramname">pNetwork</td><td>The representation of the network as got from the network topology analysis. Contains the net list representing the circuit and the list of sub-graphs that form the complete network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The table of variables is allocated dynamically. The data structure needs to be freed after use. Use destructor void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) to do so. </dd></dl>

</div>
</div>
<a class="anchor" id="ae02a9f1e602a61c03a621cefa596377c"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcUConditions" ref="ae02a9f1e602a61c03a621cefa596377c" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcUConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a constant voltage source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2e984d1032e607c3cd5a5b889f7e515"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcIConditions" ref="ac2e984d1032e607c3cd5a5b889f7e515" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcIConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a constant current source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5320557b6c76b47b226935b90aaa0f3"></a><!-- doxytag: member="les_linearEquationSystem.c::addPassiveDeviceConditions" ref="ab5320557b6c76b47b226935b90aaa0f3" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addPassiveDeviceConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a passive device (R, Y, L, C). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The terms of the equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c26718fad0c3f868f3d6debf8f8acb1"></a><!-- doxytag: member="les_linearEquationSystem.c::addOpAmpConditions" ref="a4c26718fad0c3f868f3d6debf8f8acb1" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addOpAmpConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by an operational amplifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02cc96ff59e244c57fb64207d8522dbc"></a><!-- doxytag: member="les_linearEquationSystem.c::addCurrentProbeConditions" ref="a02cc96ff59e244c57fb64207d8522dbc" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addCurrentProbeConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a current probe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab231a69f4d29015e9e8540f35a09196d"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcUByUConditions" ref="ab231a69f4d29015e9e8540f35a09196d" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcUByUConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a voltage controlled voltage source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d1383dac859561bae4cbe26cd6a5fb5"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcUByIConditions" ref="a7d1383dac859561bae4cbe26cd6a5fb5" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcUByIConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a current controlled voltage source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9252c91eb7fce311f4416097e9e21321"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcIByUConditions" ref="a9252c91eb7fce311f4416097e9e21321" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcIByUConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a voltage controlled current source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a485fd35ce69b91a773897c3e8d59b44f"></a><!-- doxytag: member="les_linearEquationSystem.c::addSrcIByIConditions" ref="a485fd35ce69b91a773897c3e8d59b44f" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addSrcIByIConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a current controlled current source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device under progress. The equation and/or terms of equations for this device are added to the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dbc03520cc2c8fc31acb9da572e9e51"></a><!-- doxytag: member="les_linearEquationSystem.c::addDeviceConditions" ref="a3dbc03520cc2c8fc31acb9da572e9e51" args="(coe_coefMatrix_t const A, const tbv_tableOfVariables_t *const pTableOfVars, unsigned int idxDev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void addDeviceConditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> const&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add those terms to the (half way completed) LES, that describe the conditions superimposed by a single device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix m*n of pointers to coefficients. Prior to the first call of this routine the matrix is initialized to all null coefficients (or NULL pointers). </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of all constants, knowns and unknows, which are used in the LES by reference. </td></tr>
    <tr><td class="paramname">idxDev</td><td>The index of the device as defined in the circuit net list object found in the table * <em>pTableOfVars</em> of symbols. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade6aacc477a37768f8df3ff55a5492ed"></a><!-- doxytag: member="les_linearEquationSystem.c::les_initModule" ref="ade6aacc477a37768f8df3ff55a5492ed" args="(log_hLogger_t hGlobalLogger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void les_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hGlobalLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the module at application startup.<br/>
 Mainly used to initialize globally accessible heap for LES coefficient objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hGlobalLogger</td><td>This module will use the passed logger object for all reporting during application life time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Do not forget to call the counterpart at application end. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="les__linear_equation_system_8c.html#a1a4234d54652d74d7ab137c4377db99d">les_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a4234d54652d74d7ab137c4377db99d"></a><!-- doxytag: member="les_linearEquationSystem.c::les_shutdownModule" ref="a1a4234d54652d74d7ab137c4377db99d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void les_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="a3e36303dc29cc0eb83a78f6a98719d34"></a><!-- doxytag: member="les_linearEquationSystem.c::les_createLES" ref="a3e36303dc29cc0eb83a78f6a98719d34" args="(les_linearEquationSystem_t **const ppLES, const pci_circuit_t *const pCircuitNetList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> les_createLES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> **const&#160;</td>
          <td class="paramname"><em>ppLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pCircuitNetList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a linear equation system that describes the ideal behavior of the electric circuit, which is decribed by a net list in the input file.<br/>
 The created LES object needs to be deleted after usage. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The input can contain a lot of logical errors, which inhibit the creation of a LES. (There are many physical constraints, like the outputs of two op-amps, which must not be directly connetced.) The function returns true if a LES could be created, false otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ppLES</td><td>The pointer to the created LES object is returned in * <em>ppLES</em> if the function succeeds. Otherwise * <em>ppLES</em> will contain NULL.<br/>
 The created object contains the matrix of coefficients of the LES plus additional, related information, e.g. about the (physical) constants refered to in the coefficients. The returned object can be input to a symbolic solver. </td></tr>
    <tr><td class="paramname">pCircuitNetList</td><td>The reference to the object that represents the parse result of the input file. It mainly contains the net list of the electric circuit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="les__linear_equation_system_8h.html#af8454e4a85aec8981f3dd267da01b0db">les_deleteLES(les_linearEquationSystem_t *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8454e4a85aec8981f3dd267da01b0db"></a><!-- doxytag: member="les_linearEquationSystem.c::les_deleteLES" ref="af8454e4a85aec8981f3dd267da01b0db" args="(les_linearEquationSystem_t *pLES)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void les_deleteLES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *&#160;</td>
          <td class="paramname"><em>pLES</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a linear equation system object. All memory is freed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pLES</td><td>The pointer to the deleted object. No action if this is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="les__linear_equation_system_8h.html#a3e36303dc29cc0eb83a78f6a98719d34">les_createLES</a>(<a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * * const, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a0ad3f23596ab4eb95fbbd2831cb888e6"></a><!-- doxytag: member="les_linearEquationSystem.c::les_getNoVariables" ref="a0ad3f23596ab4eb95fbbd2831cb888e6" args="(const les_linearEquationSystem_t *const pLES, unsigned int *const pNoKnowns, unsigned int *const pNoUnknowns, unsigned int *const pNoConstants)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void les_getNoVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pNoKnowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pNoUnknowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pNoConstants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of symbols used in the LES: The knowns, unknowns and constants. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pLES</td><td>The linear equation system object as got from a successful run of les_createLES. </td></tr>
    <tr><td class="paramname">*pNoKnowns</td><td>The number of known variables is returned in * <em>pNoKnowns</em>. </td></tr>
    <tr><td class="paramname">*pNoUnknowns</td><td>The number of unknown variables is returned in * <em>pNoUnknowns</em>. </td></tr>
    <tr><td class="paramname">*pNoConstants</td><td>The number of (physical) constants is returned in * <em>pNoConstants</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fbbf87214e42ce9a29b490b82d935d2"></a><!-- doxytag: member="les_linearEquationSystem.c::les_getTableOfVariables" ref="a3fbbf87214e42ce9a29b490b82d935d2" args="(const les_linearEquationSystem_t *const pLES)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* les_getTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get access to the table of all symbols used in the LES or related to it: The knowns, the unknowns and the (physical) constants, which appear in the coefficients. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the table of variables object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pLES</td><td>The linear equation system object as got from a successful run of les_createLES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c2df3ba31781c948f3d44710bcfab70"></a><!-- doxytag: member="les_linearEquationSystem.c::les_getTableOfUnknowns" ref="a4c2df3ba31781c948f3d44710bcfab70" args="(const les_linearEquationSystem_t *const pLES, unsigned int *const pNoUnknowns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a>* les_getTableOfUnknowns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pNoUnknowns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get access to the table of all the unknowns of the LES. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A read-only reference to the table of unknowns. The returned pointer points into the passed data structure * <em>pLES</em>; it's validity is identical to the life time of this data structure. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pLES</td><td>The linear equation system object as got from a successful run of les_createLES. </td></tr>
    <tr><td class="paramname">pNoUnknowns</td><td>If not NULL, the number of unknowns is returned in * <em>pNoUnknowns</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The entries in the returned table are not in the unknowns' order of appearance in the LES, see <a class="el" href="structtbv__unknown_variable__t.html#a56ce31820aeadcd001e5b823da7179d0">tbv_unknownVariable_t.idxCol</a>. The order of unknowns in the returned table is invariant during the life time of * <em>pLES</em>, but their order of appearance in the LES is variant; it is influenced by two functions, which select a specific unknown for the sover. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="tbv__table_of_variables_8h.html#af1b7811ea00b8c3715e2b14d5ef5eacb">tbv_setTargetUnknownForSolver</a>(<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> * const, const char * const) </dd>
<dd>
<a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="les__linear_equation_system_8h.html#a09c8dedabdd758472dfac13751e5b522">les_setupLES(les_linearEquationSystem_t * const, const char * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a09c8dedabdd758472dfac13751e5b522"></a><!-- doxytag: member="les_linearEquationSystem.c::les_setupLES" ref="a09c8dedabdd758472dfac13751e5b522" args="(les_linearEquationSystem_t *const pLES, const char *const nameOfUnknown)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> les_setupLES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfUnknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup the LES prior to running the solver.<br/>
 Currently, the solver is not capable to find a solution for all unknowns at once. As a work around this routine forms the LES in a way that the solver will return the solution of one specific, user specified unknown.<br/>
 This method can be called arbitrarily often on the same LES object after the object has been successfully created. By calling this method and the solver m times, the full solution can be figured out for a LES of size m times n. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The success. Run the solver only in case of true. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pLES</td><td>The linear equation system object as got from a successful run of les_createLES. </td></tr>
    <tr><td class="paramname">nameOfUnknown</td><td>The unknown, which the LES is to be solved for is identified by name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a470f8d09d6a16be38c7ac76067642fc3"></a><!-- doxytag: member="les_linearEquationSystem.c::_log" ref="a470f8d09d6a16be38c7ac76067642fc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a> <a class="el" href="tbv__table_of_variables_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A global logger object is referenced from anywhere for writing progress messages. </p>

</div>
</div>
<a class="anchor" id="a786f2d8bb2b0f95e8d943cd1c401db92"></a><!-- doxytag: member="les_linearEquationSystem.c::_hMemMgrSubNet" ref="a786f2d8bb2b0f95e8d943cd1c401db92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem__memory_manager_8h.html#aeacb2c05257cf2640d30be458abb4f99">mem_hHeap_t</a> <a class="el" href="les__linear_equation_system_8c.html#a786f2d8bb2b0f95e8d943cd1c401db92">_hMemMgrSubNet</a> = MEM_HANDLE_INVALID_HEAP</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A heap specific for objects of type subNetwork_t. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="les__linear_equation_system_8c.html">les_linearEquationSystem.c</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
