<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: pci_parserCircuit.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('pci__parser_circuit_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>pci_parserCircuit.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;types.h&quot;</code><br/>
<code>#include &quot;smalloc.h&quot;</code><br/>
<code>#include &quot;snprintf.h&quot;</code><br/>
<code>#include &quot;stricmp.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="rat__rational_number_8h_source.html">rat_rationalNumber.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pci__parser_circuit_8h_source.html">pci_parserCircuit.h</a>&quot;</code><br/>
<code>#include &quot;tok_tokenStream.h&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ac5fd473f13cc6b7473d4cad23d3d495a">MAX_NUMBER</a>&#160;&#160;&#160;999</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55bae74ce8bec5134f48c7a7c66ef98871fc">tokenTypePlotInfo</a> =  tok_tokenType_firstCustomToken, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55ba4e836c4536a1e77f28dbbce9e072da4b">tokenTypeAssignment</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55ba0cdb9248451e6b5f88b3512d9294b57d">tokenTypePlotLinAxis</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55ba4f28ab0bf08d2f3a0d4bbc594a859db3">tokenTypePlotLogAxis</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55bac8055ed1761b945ee78488d86ee1103a">tokenTypePlotLogAxisOld</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55ba95de0ea030a8865250540c5f2c486ca5">tokenTypeVoltageDef</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55bada44e34ab4ffec1fa28fd7dcc64736d2">tokenTypeResultDef</a>, 
<br/>
&#160;&#160;<a class="el" href="pci__parser_circuit_8c.html#a06fc87d81c62e9abb8790b6e5713c55babc4a1b928f5fd91abbdfa1af108664e8">tokenTypeBodeResultDef</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ad6e8bbb69bedf38e723767b5f9939fd6">getToken</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a078e91b389f8684ad2e94283d30c4309">openInput</a> (const char *const fileName, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> open)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aab894f479283c4adde69183e0fafe712">createParseResult</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#af3805a569623be3cf9758662aa96432b">sync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a9677f54ab86a93d502124ebed0c72c6a">enterNode</a> (unsigned int *pIdxNode, <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, const char *const nodeName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a70bc9e29dfcd384dc8b12d72cd9439d3">deviceTypeToString</a> (<a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a43286920859831b2cf718618098c35e4">findDevice</a> (unsigned int *const pIdxDev, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, <a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a> devType, const char *const devName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a3a4676c79e13089bbdb20be80facf452">enterDeviceDef</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, <a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a> devType, const char *const devName, unsigned int idxNodeAry[4], unsigned int idxDevCurrentProbe, double deviceValue, const <a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a> deviceRelation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aea2f94115da8d1641758d2a0342ff1dd">parseListOfNodes</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, unsigned int idxNodeAry[], unsigned int noNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aeeb0405d637e0915e7d93399d358e3cd">disambiguateDeviceName</a> (const char **const pNewName, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, const char *const name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aab038357b9ce5981cf2da0ed30b02f6c">parseRatNum</a> (unsigned long *pNumerator, unsigned long *pDenominator, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *pIsQuotient)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ac314204b4e6125ac1cee45e3010bde4d">parseDeviceRelation</a> (double *const pDeviceValue, <a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a> *const pDeviceRelation, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, <a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a> devType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aff0a2917e8c372101ec4f462ab88bda5">parseDevValueAssignment</a> (<a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *pAssignmentFound, double *const pDeviceValue, <a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a> *const pDeviceRelation, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, <a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a> devType, const char *const devName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ac0d31bb8619fc7b8105e1056ad37ac9b">parseDeviceDef</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#af8bb14921604b6120fe8630fa368fe36">parseOldStyleOutput</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structpci__plot_info__t.html">pci_plotInfo_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a2534302bb6701e0836546b861c82624a">parsePlotInfo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ac26e75151a52b187256715b44f7cc1dd">parseIdentifier</a> (const char *const meaningOfIdent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a5fdf6afde5969fd85979b9ea981462f3">parseVoltageDefintion</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a373c3cdf89a4c7f372cb3cc0315c86a6">parseResultDefintion</a> (<a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isFullResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ae2ab4addc221319e5fbf6e473d8e7b77">checkNodeReference</a> (const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult, unsigned int nodeIdx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a54100606247fe550ffd466b755e42e8d">checkNodeReferences</a> (const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#addb3ffb969aa271391b62319895bb21a">pci_initModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ae23ab625fdc1f49d1d6b29e63c1193d8">pci_shutdownModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aa28e260be0faacbd600bcd0c688455e9">pci_parseCircuitFile</a> (<a class="el" href="structlog__logger__t.html">log_hLogger_t</a> hLogger, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> **const ppParseResult, const char *const inputFileName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aea4a7f97acec584905826e248f219dcc">pci_cloneByConstReference</a> (const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ad151c984383830c60bf2fac34aeff3fa">pci_deleteParseResult</a> (const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *pParseResult)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a7e0574413ab653563a92f6931fccc357">pci_getNameOfDeviceType</a> (const <a class="el" href="structpci__device__t.html">pci_device_t</a> *const pDevice)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#abf737b275d869ad00e9cbaf431239991">pci_exportPlotInfoAsMCode</a> (<a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const pMScript, const <a class="el" href="structpci__plot_info__t.html">pci_plotInfo_t</a> *const pPlotInfo, const char *indentStr)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a70c9a1d143798ba1eb42d5e26929c1b0">_hTokenStream</a> = TOK_HANDLE_TO_INVALID_TOKEN_STREAM</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtok__token__t.html">tok_token_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a3222acfc668de2422bdce02b3b2a1e41">_token</a> = TOK_UNINITIALIZED_TOKEN</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#aa2e6009a256b25f31ab9109f18c669ae">_parseError</a> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a2c99a080d0f9c762dd7720f9847714d9">_isStdFormat</a> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ad227ec6d19cab05fa848acad3f8222f2">_noOldStyleInputDefs</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#ae1c8194030cff0996c8a6056a5eb55e7">_strcmp</a> )(const char *str1, const char *str2) = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pci__parser_circuit_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Parser for the circuit definition, *.cnl, file. All device definitions are read and the network graph is stored as a linear list of branches. In parallel a list of device names and sources is build together with a set of relations between devices of same type. Additionally, the devices get their default numerical values.<br/>
 Caution, the implementation make intensive use of global data; the parser is in no way reentrant. Only one parse process can be run at a time.</p>
<p>Copyright (C) 2013-2014 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ac5fd473f13cc6b7473d4cad23d3d495a"></a><!-- doxytag: member="pci_parserCircuit.c::MAX_NUMBER" ref="ac5fd473f13cc6b7473d4cad23d3d495a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_NUMBER&#160;&#160;&#160;999</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="pci_parserCircuit.c::@0" ref="a06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The underlying tokenizer knowns some built-in lexical tokens like numeric literals but this parser needs to define some addition tokens in order to descibe the formal syntax of a circuit file. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55bae74ce8bec5134f48c7a7c66ef98871fc"></a><!-- doxytag: member="tokenTypePlotInfo" ref="a06fc87d81c62e9abb8790b6e5713c55bae74ce8bec5134f48c7a7c66ef98871fc" args="" -->tokenTypePlotInfo</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4e836c4536a1e77f28dbbce9e072da4b"></a><!-- doxytag: member="tokenTypeAssignment" ref="a06fc87d81c62e9abb8790b6e5713c55ba4e836c4536a1e77f28dbbce9e072da4b" args="" -->tokenTypeAssignment</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba0cdb9248451e6b5f88b3512d9294b57d"></a><!-- doxytag: member="tokenTypePlotLinAxis" ref="a06fc87d81c62e9abb8790b6e5713c55ba0cdb9248451e6b5f88b3512d9294b57d" args="" -->tokenTypePlotLinAxis</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba4f28ab0bf08d2f3a0d4bbc594a859db3"></a><!-- doxytag: member="tokenTypePlotLogAxis" ref="a06fc87d81c62e9abb8790b6e5713c55ba4f28ab0bf08d2f3a0d4bbc594a859db3" args="" -->tokenTypePlotLogAxis</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55bac8055ed1761b945ee78488d86ee1103a"></a><!-- doxytag: member="tokenTypePlotLogAxisOld" ref="a06fc87d81c62e9abb8790b6e5713c55bac8055ed1761b945ee78488d86ee1103a" args="" -->tokenTypePlotLogAxisOld</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba95de0ea030a8865250540c5f2c486ca5"></a><!-- doxytag: member="tokenTypeVoltageDef" ref="a06fc87d81c62e9abb8790b6e5713c55ba95de0ea030a8865250540c5f2c486ca5" args="" -->tokenTypeVoltageDef</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55bada44e34ab4ffec1fa28fd7dcc64736d2"></a><!-- doxytag: member="tokenTypeResultDef" ref="a06fc87d81c62e9abb8790b6e5713c55bada44e34ab4ffec1fa28fd7dcc64736d2" args="" -->tokenTypeResultDef</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55babc4a1b928f5fd91abbdfa1af108664e8"></a><!-- doxytag: member="tokenTypeBodeResultDef" ref="a06fc87d81c62e9abb8790b6e5713c55babc4a1b928f5fd91abbdfa1af108664e8" args="" -->tokenTypeBodeResultDef</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad6e8bbb69bedf38e723767b5f9939fd6"></a><!-- doxytag: member="pci_parserCircuit.c::getToken" ref="ad6e8bbb69bedf38e723767b5f9939fd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> getToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the next token from the input stream into the global variable. Emit an error message if this fails. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if no syntax or stream error appeared. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a078e91b389f8684ad2e94283d30c4309"></a><!-- doxytag: member="pci_parserCircuit.c::openInput" ref="a078e91b389f8684ad2e94283d30c4309" args="(const char *const fileName, boolean open)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> openInput </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>open</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open (or close) the input file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if streams could be initialized as wanted, else false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Name of circuit file to be opened and parsed. </td></tr>
    <tr><td class="paramname">open</td><td>Boolean flag. Pass true to open the streams and - after parsing - call again and pass false to close the input file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab894f479283c4adde69183e0fafe712"></a><!-- doxytag: member="pci_parserCircuit.c::createParseResult" ref="aab894f479283c4adde69183e0fafe712" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a>* createParseResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty parse result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to malloc allocated object is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="af3805a569623be3cf9758662aa96432b"></a><!-- doxytag: member="pci_parserCircuit.c::sync" ref="af3805a569623be3cf9758662aa96432b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize parser with input stream after an error. We read without understanding until the next line or sentence. From here, we have a chance to see meaningful input again. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9677f54ab86a93d502124ebed0c72c6a"></a><!-- doxytag: member="pci_parserCircuit.c::enterNode" ref="a9677f54ab86a93d502124ebed0c72c6a" args="(unsigned int *pIdxNode, pci_circuit_t *const pParseResult, const char *const nodeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> enterNode </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pIdxNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nodeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a node in the parse result - or enter it into the parse result if not found. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if returned index is valid, otherwise false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIdxNode</td><td>The index of the node in the array of all nodes is written into <em>*</em> pIdxNode. Or PCI_NULL_NODE if the maximum number of supported nodes has been exceeded. </td></tr>
    <tr><td class="paramname">pParseResult</td><td>The parse result as known so far. </td></tr>
    <tr><td class="paramname">nodeName</td><td>The name of the node to look up. A malloc allocated string is expected. If the function succeeds then * <em>pParseResult</em> takes the ownership. Otherwise the caller remains responsible for freeing the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a70bc9e29dfcd384dc8b12d72cd9439d3"></a><!-- doxytag: member="pci_parserCircuit.c::deviceTypeToString" ref="a70bc9e29dfcd384dc8b12d72cd9439d3" args="(pci_deviceType_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* deviceTypeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query a readable name for a supported device type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the name as a pointer to a constant character string. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The device type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43286920859831b2cf718618098c35e4"></a><!-- doxytag: member="pci_parserCircuit.c::findDevice" ref="a43286920859831b2cf718618098c35e4" args="(unsigned int *const pIdxDev, const pci_circuit_t *const pParseResult, pci_deviceType_t devType, const char *const devName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> findDevice </td>
          <td>(</td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pIdxDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a>&#160;</td>
          <td class="paramname"><em>devType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>devName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Serach for a device by type and name in the half-way completed parse result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if the device is found, <em>false</em> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pIdxDev</td><td>The index to the found device is placed in <em>*</em> pIdxDev. If the function fails then PCI_NULL_DEVICE is returned. </td></tr>
    <tr><td class="paramname">pParseResult</td><td>The searched parse result. </td></tr>
    <tr><td class="paramname">devType</td><td>The demanded type of the device. </td></tr>
    <tr><td class="paramname">devName</td><td>The demanded name of the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a4676c79e13089bbdb20be80facf452"></a><!-- doxytag: member="pci_parserCircuit.c::enterDeviceDef" ref="a3a4676c79e13089bbdb20be80facf452" args="(pci_circuit_t *const pParseResult, pci_deviceType_t devType, const char *const devName, unsigned int idxNodeAry[4], unsigned int idxDevCurrentProbe, double deviceValue, const pci_deviceRelation_t deviceRelation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> enterDeviceDef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a>&#160;</td>
          <td class="paramname"><em>devType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>devName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNodeAry</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevCurrentProbe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>deviceValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a>&#160;</td>
          <td class="paramname"><em>deviceRelation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enter the parsed information concerning a device in the parse result structure. The next element of the device array is filled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if operation succeeded, <em>false</em> in case of out of memory. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parse result is placed in <em>*</em> pParseResult. </td></tr>
    <tr><td class="paramname">devType</td><td>The type of the device. </td></tr>
    <tr><td class="paramname">devName</td><td>The name of the device. A malloc allocates string is expected. If the function succeeds then * <em>pParseResult</em> takes the ownership. Otherwise the caller remains responsible for freeing the string. </td></tr>
    <tr><td class="paramname">idxNodeAry</td><td>The array of indexes of nodes the device is connected to. The device type determines how many nodes have to be present in the array. The remaining array elements don't care. </td></tr>
    <tr><td class="paramname">idxDevCurrentProbe</td><td>Only used for current controlled sources: The device index of the current probe, which controles the source. PCI_NULL_DEVICE for all other devices. </td></tr>
    <tr><td class="paramname">deviceValue</td><td>The device value to be used for simulation and plotting if specified or a negative value otherwise. </td></tr>
    <tr><td class="paramname">deviceRelation</td><td>The device value in relation to another device. An invalid reference is passed if no such relation is specified in the input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aea2f94115da8d1641758d2a0342ff1dd"></a><!-- doxytag: member="pci_parserCircuit.c::parseListOfNodes" ref="aea2f94115da8d1641758d2a0342ff1dd" args="(pci_circuit_t *const pParseResult, unsigned int idxNodeAry[], unsigned int noNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseListOfNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNodeAry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a given number of node names from the input stream. The node names are registered in the parse result (if the nodes are not yet known) and the indexes of the nodes in the parse result are returned. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if all nodes could be read from the input, <em>false</em> otherwise. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parsed node information is placed in <em>*</em> pParseResult. </td></tr>
    <tr><td class="paramname">idxNodeAry</td><td>The indexes of the nodes with the parsed names are placed into this array. It has room for at least <em>noNodes</em> entries. The contents are undefined if the function returns <em>false</em>. </td></tr>
    <tr><td class="paramname">noNodes</td><td>The expected number of nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aeeb0405d637e0915e7d93399d358e3cd"></a><!-- doxytag: member="pci_parserCircuit.c::disambiguateDeviceName" ref="aeeb0405d637e0915e7d93399d358e3cd" args="(const char **const pNewName, const pci_circuit_t *const pParseResult, const char *const name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> disambiguateDeviceName </td>
          <td>(</td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>pNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's structurally basically possible to have different devices of same name. If devices of same name are properly related (i.e. it's explicitly stated that they have the same physical value) then it will even lead to a useful result. In all other cases the result's representation is ambiguous and misleading (but not wrong). The old input syntax supported devices of same name; today's standard format doesn't. To stay compatible with the elder input format, identical names are changed now, it's not considered an error with termination. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if parsing can continue. The standard format forbids to have ambiguous names, the function returns false if a forbidden ambiguity is recognized. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNewName</td><td>A malloc allocated pointer with a unique device name is returned in * <em>pNewName</em>. The function can operate in place; if you pass a variable <em>n</em> as <em>name</em> then you may pass the address of <em>n</em> as <em>pNewName</em>. </td></tr>
    <tr><td class="paramname">pParseResult</td><td>The current state of parse result is checked for an identical name. </td></tr>
    <tr><td class="paramname">name</td><td>The checked device name. A malloc allocated string is expected. If it is found to be ambiguous it is made unique by appending a suffix. name is freed and then a new call of malloc is made to allocate memory for the new, returned name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aab038357b9ce5981cf2da0ed30b02f6c"></a><!-- doxytag: member="pci_parserCircuit.c::parseRatNum" ref="aab038357b9ce5981cf2da0ed30b02f6c" args="(unsigned long *pNumerator, unsigned long *pDenominator, boolean *pIsQuotient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseRatNum </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pNumerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>pDenominator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td>
          <td class="paramname"><em>pIsQuotient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a rational number, which is represented by a quotient of two (positive) integers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><em>true</em> if operation succeeded, <em>false</em> in case of a syntax error. If <em>false</em> is returned then a message has been written to the log and all other results are undefined. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pNumerator</td><td>The numerator of the rational number is placed in * <em>pNumerator</em>. </td></tr>
    <tr><td class="paramname">pDenominator</td><td>The denominator of the rational number is placed in * <em>pDenominator</em>. </td></tr>
    <tr><td class="paramname">pIsQuotient</td><td>The rational number can be explicitly expressed as a quotient of two integers but for denominator=1 it can also be expressed as a single integer. In the former case this flag is to <em>true</em>, in the latter case it is set to <em>false</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac314204b4e6125ac1cee45e3010bde4d"></a><!-- doxytag: member="pci_parserCircuit.c::parseDeviceRelation" ref="ac314204b4e6125ac1cee45e3010bde4d" args="(double *const pDeviceValue, pci_deviceRelation_t *const pDeviceRelation, const pci_circuit_t *const pParseResult, pci_deviceType_t devType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseDeviceRelation </td>
          <td>(</td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>pDeviceValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a> *const&#160;</td>
          <td class="paramname"><em>pDeviceRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a>&#160;</td>
          <td class="paramname"><em>devType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the value of a device constant assignment. Either a number or a multiple of another, already known device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if parsing succeeded, else false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pDeviceValue</td><td>If the function succeeds then the physical value of the device is placed in * <em>pDeviceValue</em> if it is specified absolute. </td></tr>
    <tr><td class="paramname">pDeviceRelation</td><td>The parse result is placed in * <em>pDeviceRelation</em> if the device is related to another, already known. </td></tr>
    <tr><td class="paramname">pParseResult</td><td>The parse result so far. Used to identify a referenced, already defined other device. </td></tr>
    <tr><td class="paramname">devType</td><td>The kind of device under progress. Needed to double-check whether a referenced device is of same type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aff0a2917e8c372101ec4f462ab88bda5"></a><!-- doxytag: member="pci_parserCircuit.c::parseDevValueAssignment" ref="aff0a2917e8c372101ec4f462ab88bda5" args="(boolean *pAssignmentFound, double *const pDeviceValue, pci_deviceRelation_t *const pDeviceRelation, const pci_circuit_t *const pParseResult, pci_deviceType_t devType, const char *const devName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseDevValueAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td>
          <td class="paramname"><em>pAssignmentFound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *const&#160;</td>
          <td class="paramname"><em>pDeviceValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpci__device_relation__t.html">pci_deviceRelation_t</a> *const&#160;</td>
          <td class="paramname"><em>pDeviceRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pci__parser_circuit_8h.html#ae3a5c6bd4d8714fd9a656c819c7cdb4f">pci_deviceType_t</a>&#160;</td>
          <td class="paramname"><em>devType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>devName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the (optional) appendix to a device definition that specifies the value of the physical constant of that device. Used for result simplification and plotting. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if parsing succeeded, else false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pAssignmentFound</td><td>The value definition is optional. If one is found then true is placed in * <em>pAssignmentFound</em>, otherwise false. The other output variables have not been written if * <em>pAssignmentFound</em> is false after return. </td></tr>
    <tr><td class="paramname">pDeviceValue</td><td>The physical value of the device is placed in * <em>pDeviceValue</em> if it is specified absolute. </td></tr>
    <tr><td class="paramname">pDeviceRelation</td><td>The parse result is placed in * <em>pDeviceRelation</em> if the device is related to another, already known. </td></tr>
    <tr><td class="paramname">pParseResult</td><td>The parse result so far. Used to identify a referenced, already defined other device. </td></tr>
    <tr><td class="paramname">devType</td><td>The syntax of the term depends on the type of the device. </td></tr>
    <tr><td class="paramname">devName</td><td>The term may refer to the device by name. Pass the name to enable a cross check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0d31bb8619fc7b8105e1056ad37ac9b"></a><!-- doxytag: member="pci_parserCircuit.c::parseDeviceDef" ref="ac0d31bb8619fc7b8105e1056ad37ac9b" args="(pci_circuit_t *const pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseDeviceDef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a line that contains the defintion of a single device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if parsing succeeded, else false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parse result is placed in <em>*</em> pParseResult. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="af8bb14921604b6120fe8630fa368fe36"></a><!-- doxytag: member="pci_parserCircuit.c::parseOldStyleOutput" ref="af8bb14921604b6120fe8630fa368fe36" args="(pci_circuit_t *const pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseOldStyleOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the definition of the output voltage as defined for the old input syntax. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns true if the definition could be parsed error free. If it returns false than all according error messages and hints have been written to the log file. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parse result is placed in <em>*</em> pParseResult if the function succeeds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2534302bb6701e0836546b861c82624a"></a><!-- doxytag: member="pci_parserCircuit.c::parsePlotInfo" ref="a2534302bb6701e0836546b861c82624a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structpci__plot_info__t.html">pci_plotInfo_t</a>* parsePlotInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the plot supporting information, which is a self-contained syntax element in the old format and optional part of a result definition in the standard format. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get either a malloc allocated plot info object or NULL in case of errors. Sufficient error information has been written to the log if NULL is returned. </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Differently to many other parse function this function expects to still see the first token of the plot info, which had been used to recognize that there is such a plot info. Do not advance the token stream beyond the initial .AC, DEC, or LOG prior to the call of this function. </dd>
<dd>
The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac26e75151a52b187256715b44f7cc1dd"></a><!-- doxytag: member="pci_parserCircuit.c::parseIdentifier" ref="ac26e75151a52b187256715b44f7cc1dd" args="(const char *const meaningOfIdent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* parseIdentifier </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>meaningOfIdent</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse an identifier, which is basically a function of the underlaying tokenizer; this functiions adds some general error handling. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the malloc allocated string holding the parsed identifier - or NULL if a problem appeared. If so, all appropriate information has been written to the log. The function caller becomes the owner of the returned string and needs to do a free after use. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">meaningOfIdent</td><td>A short string that indicates the meaning of the parsed indentifier. The string makes the error messages more meaningful. Should start with a capital letter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fdf6afde5969fd85979b9ea981462f3"></a><!-- doxytag: member="pci_parserCircuit.c::parseVoltageDefintion" ref="a5fdf6afde5969fd85979b9ea981462f3" args="(pci_circuit_t *const pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseVoltageDefintion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a line, which defines a voltage of interest as the difference of two nodes' electric potentials. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns true if the definition could be parsed error free. If it returns false than all according error messages and hints have been written to the log file. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parse result is placed in <em>*</em> pParseResult. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a373c3cdf89a4c7f372cb3cc0315c86a6"></a><!-- doxytag: member="pci_parserCircuit.c::parseResultDefintion" ref="a373c3cdf89a4c7f372cb3cc0315c86a6" args="(pci_circuit_t *const pParseResult, boolean isFullResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> parseResultDefintion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>isFullResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a line, which defines a user wanted result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns true if the definition could be parsed error free. If it returns false than all according error messages and hints have been written to the log file. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The parse result is placed in <em>*</em> pParseResult. </td></tr>
    <tr><td class="paramname">isFullResult</td><td>Full result and Bode plot are both handled by this function. Pass, which keyword had been seen, which of the two cases should be handled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The global error flag <em>_parseError</em> is set and a message is written to the log in case of an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2ab4addc221319e5fbf6e473d8e7b77"></a><!-- doxytag: member="pci_parserCircuit.c::checkNodeReference" ref="ae2ab4addc221319e5fbf6e473d8e7b77" args="(const pci_circuit_t *const pParseResult, unsigned int nodeIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> checkNodeReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nodeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Validate that a node is a true, physical network node, i.e. that it really is connected to an electrical connector of a device (but not only to a voltage sense input or not at all). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>false</em> and emitts a message if a problem is found. Otherwise it returns <em>true</em>; </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The completed parse result, which is under validation. </td></tr>
    <tr><td class="paramname">nodeIdx</td><td>The node index to validate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54100606247fe550ffd466b755e42e8d"></a><!-- doxytag: member="pci_parserCircuit.c::checkNodeReferences" ref="a54100606247fe550ffd466b755e42e8d" args="(const pci_circuit_t *const pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> checkNodeReferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The definition of the system output using tag U2 in the elder format and the voltage sensing inputs of a voltage controlled source support forward references (as most existing circuit files tend to place the tags U1 and U2 at the beginning). The character of a forward reference is that it might be not satisfied at the end of parsing.<br/>
 This function should be called after parsing has been completed in order to find out if the nodes referenced by voltage controlled sources or the system output definition of the elder format are valid nodes of the circuit. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns <em>false</em> and emitts a message if a problem is found. Otherwise it returns <em>true</em>; </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>The completed parse result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addb3ffb969aa271391b62319895bb21a"></a><!-- doxytag: member="pci_parserCircuit.c::pci_initModule" ref="addb3ffb969aa271391b62319895bb21a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pci_initModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the module at application startup. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="pci__parser_circuit_8c.html#ae23ab625fdc1f49d1d6b29e63c1193d8">pci_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae23ab625fdc1f49d1d6b29e63c1193d8"></a><!-- doxytag: member="pci_parserCircuit.c::pci_shutdownModule" ref="ae23ab625fdc1f49d1d6b29e63c1193d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pci_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="aa28e260be0faacbd600bcd0c688455e9"></a><!-- doxytag: member="pci_parserCircuit.c::pci_parseCircuitFile" ref="aa28e260be0faacbd600bcd0c688455e9" args="(log_hLogger_t hLogger, const pci_circuit_t **const ppParseResult, const char *const inputFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> pci_parseCircuitFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> **const&#160;</td>
          <td class="paramname"><em>ppParseResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>inputFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the input file. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns true if the file could be parsed entirely error free. If it returns false than all according error messages and hints have been written to the log file. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>The handle to an opened and configured logger is passed to the function. All progressa and result messages are written to the logger. </td></tr>
    <tr><td class="paramname">ppParseResult</td><td>The pointer to the parse result object is placed in <em>*</em> ppParseResult. After usage the reference to the data structure needs to be released with <em>pci_deleteParseResult</em>.<br/>
 The returned pointer is valid only if the function returns true. </td></tr>
    <tr><td class="paramname">inputFileName</td><td>The name of the circuit file to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *pci_cloneByConstReference(const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * const) </dd>
<dd>
void pci_deleteParseResult(const pci_deviceRelation_t *pParseResult) </dd></dl>

</div>
</div>
<a class="anchor" id="aea4a7f97acec584905826e248f219dcc"></a><!-- doxytag: member="pci_parserCircuit.c::pci_cloneByConstReference" ref="aea4a7f97acec584905826e248f219dcc" args="(const pci_circuit_t *const pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a>* pci_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request a reference to a parse result object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with pci_deleteParseResult after use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the passed pointer <em>pParseResult</em> is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>Pointer to the object to be cloned by reference. The object has originally been created by a successful call of pci_parseCircuitFile, but another copied reference got from this function may also be passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="pci__parser_circuit_8h.html#a1f68365bce8e5dc445a89be3df68f7a5">pci_parseCircuitFile</a>(<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * * const, const char * const) </dd>
<dd>
void <a class="el" href="pci__parser_circuit_8h.html#ad151c984383830c60bf2fac34aeff3fa">pci_deleteParseResult(const pci_circuit_t *)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad151c984383830c60bf2fac34aeff3fa"></a><!-- doxytag: member="pci_parserCircuit.c::pci_deleteParseResult" ref="ad151c984383830c60bf2fac34aeff3fa" args="(const pci_circuit_t *pParseResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pci_deleteParseResult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *&#160;</td>
          <td class="paramname"><em>pParseResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a reference to a parse result object after use. If there are no references left then the object itself is deleted, all memory is freed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pParseResult</td><td>* <em>pParseResult</em> is the unchanged parse result as got from pci_parseCircuitFile before. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="pci__parser_circuit_8h.html#a1f68365bce8e5dc445a89be3df68f7a5">pci_parseCircuitFile</a>(<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * * const, const char * const) </dd>
<dd>
const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *pci_cloneByConstReference(const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a7e0574413ab653563a92f6931fccc357"></a><!-- doxytag: member="pci_parserCircuit.c::pci_getNameOfDeviceType" ref="a7e0574413ab653563a92f6931fccc357" args="(const pci_device_t *const pDevice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pci_getNameOfDeviceType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpci__device__t.html">pci_device_t</a> *const&#160;</td>
          <td class="paramname"><em>pDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query a readable name for the type of a device. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the type name as a pointer to a constant read-only character string. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pDevice</td><td>The pointer to the device to query the type name for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf737b275d869ad00e9cbaf431239991"></a><!-- doxytag: member="pci_parserCircuit.c::pci_exportPlotInfoAsMCode" ref="abf737b275d869ad00e9cbaf431239991" args="(msc_mScript_t *const pMScript, const pci_plotInfo_t *const pPlotInfo, const char *indentStr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pci_exportPlotInfoAsMCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const&#160;</td>
          <td class="paramname"><em>pMScript</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__plot_info__t.html">pci_plotInfo_t</a> *const&#160;</td>
          <td class="paramname"><em>pPlotInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>indentStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Render a plot information object as Octave script code. The object is represented as a M code struct; the generated M code can e.g. be used as RHS of an assignment. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pPlotInfo</td><td>The reference to the rendered plot information object is passed. NULL may be passed if no specific plot information is known and plot attributes are modelled as "don't care". </td></tr>
    <tr><td class="paramname">pMScript</td><td>The pointer to an M script object. The generated M code is written into this M script. The object is the result of a successful call of boolean msc_createMScript(<a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> ** const, const char * const, const char * const, const char * const). </td></tr>
    <tr><td class="paramname">indentStr</td><td>The generated code starts with a new line. This and each other required line will begin with the passed string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a470f8d09d6a16be38c7ac76067642fc3"></a><!-- doxytag: member="pci_parserCircuit.c::_log" ref="a470f8d09d6a16be38c7ac76067642fc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a> <a class="el" href="tbv__table_of_variables_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A global logger object is referenced from anywhere for writing progress messages. </p>

</div>
</div>
<a class="anchor" id="a70c9a1d143798ba1eb42d5e26929c1b0"></a><!-- doxytag: member="pci_parserCircuit.c::_hTokenStream" ref="a70c9a1d143798ba1eb42d5e26929c1b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> <a class="el" href="pci__parser_circuit_8c.html#a70c9a1d143798ba1eb42d5e26929c1b0">_hTokenStream</a> = TOK_HANDLE_TO_INVALID_TOKEN_STREAM<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For simplicity all functions read the next input token from a global stream object. </p>

</div>
</div>
<a class="anchor" id="a3222acfc668de2422bdce02b3b2a1e41"></a><!-- doxytag: member="pci_parserCircuit.c::_token" ref="a3222acfc668de2422bdce02b3b2a1e41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtok__token__t.html">tok_token_t</a> <a class="el" href="pci__parser_circuit_8c.html#a3222acfc668de2422bdce02b3b2a1e41">_token</a> = TOK_UNINITIALIZED_TOKEN<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For simplicity all functions find the current input token in a global object. </p>

</div>
</div>
<a class="anchor" id="aa2e6009a256b25f31ab9109f18c669ae"></a><!-- doxytag: member="pci_parserCircuit.c::_parseError" ref="aa2e6009a256b25f31ab9109f18c669ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="pci__parser_circuit_8c.html#aa2e6009a256b25f31ab9109f18c669ae">_parseError</a> = false<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The overall parse result can be accessed from any nested sub-routine. We use a global variable to implement this. </p>

</div>
</div>
<a class="anchor" id="a2c99a080d0f9c762dd7720f9847714d9"></a><!-- doxytag: member="pci_parserCircuit.c::_isStdFormat" ref="a2c99a080d0f9c762dd7720f9847714d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="pci__parser_circuit_8c.html#a2c99a080d0f9c762dd7720f9847714d9">_isStdFormat</a> = false<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The parser still supports an old-fashioned style of circuit input files, which is compatible with the net list of an early release of the simulation tool SPICE.<br/>
 At run-time, this flag indicates to the parser's sub-routines, which input format to support. true means the new, standard format. </p>

</div>
</div>
<a class="anchor" id="ad227ec6d19cab05fa848acad3f8222f2"></a><!-- doxytag: member="pci_parserCircuit.c::_noOldStyleInputDefs" ref="ad227ec6d19cab05fa848acad3f8222f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="pci__parser_circuit_8c.html#ad227ec6d19cab05fa848acad3f8222f2">_noOldStyleInputDefs</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae1c8194030cff0996c8a6056a5eb55e7"></a><!-- doxytag: member="pci_parserCircuit.c::_strcmp" ref="ae1c8194030cff0996c8a6056a5eb55e7" args=")(const char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int(* <a class="el" href="pci__parser_circuit_8c.html#ae1c8194030cff0996c8a6056a5eb55e7">_strcmp</a>)(const char *str1, const char *str2) = NULL<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The parser is case insenitive for the elder format and case sensitive for the standard format. This is handled by using this global function pointer for all string tests. </p>

</div>
</div>
<a class="anchor" id="a470a463163890645f09c7b90f2e1de48"></a><!-- doxytag: member="pci_parserCircuit.c::_noRefsToObjects" ref="a470a463163890645f09c7b90f2e1de48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="log__logger_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A global counter of all references to any created objects. Used to detect memory leaks. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="pci__parser_circuit_8c.html">pci_parserCircuit.c</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
