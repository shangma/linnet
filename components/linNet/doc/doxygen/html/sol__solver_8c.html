<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: sol_solver.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('sol__solver_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>sol_solver.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;smalloc.h&quot;</code><br/>
<code>#include &quot;log_logger.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8h_source.html">coe_coefficient.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8inline_interface_8h_source.html">coe_coefficient.inlineInterface.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="les__linear_equation_system_8h_source.html">les_linearEquationSystem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sol__solver_8h_source.html">sol_solver.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a021b7219e3298775649324ec456a9804">getVectorOfReqDependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aedc43b8796301c165a786315c5c57d90">elementaryStep</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> A, signed int step, signed int row, signed int col, const <a class="el" href="structcoe__coef_addend__t.html">coe_coef_t</a> *const pKnownDivisor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aff468c335d34a6496b62e994f0f30162">solverLES</a> (<a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a> A, const unsigned int m, const unsigned int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#ad7c5e605e92d71da8ab69fb67c37d8f9">sol_initModule</a> (<a class="el" href="structlog__logger__t.html">log_hLogger_t</a> hLogger)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a2f3179cdc36acefb42c3e129d4f92bed">sol_shutdownModule</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const ppSolution, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a8d81cb47f1e0a03919e32789e78c9074">sol_cloneByReference</a> (<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a3ea66ad9c92eda2b59b5cb8963a326b4">sol_cloneByConstReference</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pConstSolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a527fc6c1da24df65513f4036cd909007">sol_getNameOfIndependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxIndependent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a3aaa4786664dd4ee550cbe77ef1041cd">sol_getNoDependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#ac0c1a84b78261db41e91cb0c468d0933">sol_findName</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, signed int *const pIdxSolution, signed int *const pIdxUnknown, signed int *const pIdxUserDefVoltage, signed int *const pIdxKnown, const char *const nameOfQuantity, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> doErrorReporting)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aa25eb1220d206469381d3734eb6cef4e">sol_getNameOfDependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxSolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a90202b666b29d26fa9783a53a7f204b1">sol_logSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *pSolution, <a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a> logLevel)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Symbolic solver for linear equations systems (LES)</p>
<p>Copyright (C) 2013-2014 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a021b7219e3298775649324ec456a9804"></a><!-- doxytag: member="sol_solver.c::getVectorOfReqDependents" ref="a021b7219e3298775649324ec456a9804" args="(const sol_solution_t *const pSolution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>* getVectorOfReqDependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The set of dependents(i.e. the unknowns of the LES and the user defined voltages), which are required to compute all user defined results is figured out. All unknowns of the LES, which are not in the set don't need to be computed by the solver. The set considers all user-defined results, which may directly refer to unknowns of the LES but also indirectly by referencing user-defined voltages. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set is returned as an ordered vector of Boolean, where element <em>i</em> of the vector relates to unknown <em>i</em> of the LES, if <em>i</em> is lower then the number <em>n</em> of unknowns. Otherwise element <em>i</em> refers to user defined voltage <em>i</em> - <em>n</em>. The related dependent is required if the element is <em>true</em>.<br/>
 The returned vector is malloc allocated and needs to be freed after use. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. If called during object construction: The table of variables and the circuit net list need to be setup before this function may be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedc43b8796301c165a786315c5c57d90"></a><!-- doxytag: member="sol_solver.c::elementaryStep" ref="aedc43b8796301c165a786315c5c57d90" args="(coe_coefMatrix_t A, signed int step, signed int row, signed int col, const coe_coef_t *const pKnownDivisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void elementaryStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcoe__coef_addend__t.html">coe_coef_t</a> *const&#160;</td>
          <td class="paramname"><em>pKnownDivisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The most basic operation of the extended Gauss elimination. It re-computes one coefficient of the LES according to: A(m,n)=(A(m,n)*A(step,step)-A(step,n)*A(m,step))/t. The extension of the known Gauss elimination is the specification of t, which is a known divisor; the division can be carried out without a remainder. Normally the Gauss elimination is defined for algebraic structure of kind field; because of the divisor we can apply it to the simpler ring.<br/>
 Here, the elementary step is implemented for linear combinations having products of symbols as coefficients. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix of coefficients, which are manipulated in place. The result is returned in place. </td></tr>
    <tr><td class="paramname">step</td><td>The elimination step of the Gauss elimination. In fact, step+i, i = 1..m-step-1, are the indexes of the equations which are manipulated to get another leading null coefficient. </td></tr>
    <tr><td class="paramname">row</td><td>The row index of the coefficient under operation. </td></tr>
    <tr><td class="paramname">col</td><td>The column index of the coefficient under operation. </td></tr>
    <tr><td class="paramname">pKnownDivisor</td><td>The known divisor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff468c335d34a6496b62e994f0f30162"></a><!-- doxytag: member="sol_solver.c::solverLES" ref="aff468c335d34a6496b62e994f0f30162" args="(coe_coefMatrix_t A, const unsigned int m, const unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> solverLES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcoe__coef_addend__t.html">coe_coefMatrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The solver for a linear equation system.<br/>
 The system is solved by the modified Gaussian elimination method. The required algebraic structure the coefficients belongs to is less demanding than for the original elimination: The division is not required. The modified elimination can e.g. be performed with integer numbers. The coefficients' algebraic structure needs to have the sum and the multiplication operation.<br/>
 The arithmetic is not done in this routine; it only implements the control structure. The algebraic operations on the coefficients are solely done in the sub-routine elementaryOperation. By exchanging this sub-routine the solver could be used for other sets of coefficients.<br/>
 A possible impact of the actual arithmetics on the control structure in this routine could be a round off error of the multiplikation operation. True pivoting could become an issue. The current implementation of the control structure just implements a simple pivoting, which suffices for error-free sum and multiplication. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns true if the LES could be solved. false ii e.g. returned in case of linearly dependent equations. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The array of coefficients, which are manipulated in place. The result is returned in place.<br/>
 The array is organized as m rows and n columns, where n &gt;= m+1. The rectangular area A[0..m-1][0..m-1] holds the coefficients belonging to the m unknowns. If the algorithm returns true than this area is a diagonal matrix, where A[i][i], i=0..m-1, holds the denominator of the solution for unknown i.<br/>
 A[0..m-1][m..n-1] holds the left hand side of the LES (where the sign of these coefficients is such that the sum of all row elements becomes null). Column i, i=m..n-1, holds the coefficients belonging to the known input variable i-m. If the algorithm returns true than this area contains the numerators of the solution. A[i][j+m]*V_j, i=0..m-1, j=0..n-m-1, is the complete numerator of the result for unknown i. </td></tr>
    <tr><td class="paramname">m</td><td>The number <em>m</em> of rows of the matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">n</td><td>The number <em>n</em> of columns of the matrix <em>A</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void elementaryStep(coe_coefMatrix_t, int, int, int, coe_coef_t *) </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c5e605e92d71da8ab69fb67c37d8f9"></a><!-- doxytag: member="sol_solver.c::sol_initModule" ref="ad7c5e605e92d71da8ab69fb67c37d8f9" args="(log_hLogger_t hLogger)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the module at application startup. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="sol__solver_8c.html#a2f3179cdc36acefb42c3e129d4f92bed">sol_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2f3179cdc36acefb42c3e129d4f92bed"></a><!-- doxytag: member="sol_solver.c::sol_shutdownModule" ref="a2f3179cdc36acefb42c3e129d4f92bed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="aa25a90cbcbfddb816c292214eb790459"></a><!-- doxytag: member="sol_solver.c::sol_createSolution" ref="aa25a90cbcbfddb816c292214eb790459" args="(const sol_solution_t **const ppSolution, les_linearEquationSystem_t *const pLES)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> sol_createSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const&#160;</td>
          <td class="paramname"><em>ppSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The complete solution of a LES is figured out and returned as a new object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if and only if the operation entirely succeeded. Otherwise the function returns false and appropriate error messages have been written to the global application log. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ppSolution</td><td>The pointer to the new object is returned in * <em>ppSolution</em>. The solution object can be used to report the result of the LES or for further processing (like numeric evaluation). Do not use * <em>ppSolution</em> if the function returns false. </td></tr>
    <tr><td class="paramname">pLES</td><td>The LES is passed by reference. The passed object is the successful result of les_createLES. * <em>pLES</em> may be deleted after return of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d81cb47f1e0a03919e32789e78c9074"></a><!-- doxytag: member="sol_solver.c::sol_cloneByReference" ref="a8d81cb47f1e0a03919e32789e78c9074" args="(sol_solution_t *const pExistingObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request another reference to an existing object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByConstReference(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea66ad9c92eda2b59b5cb8963a326b4"></a><!-- doxytag: member="sol_solver.c::sol_cloneByConstReference" ref="a3ea66ad9c92eda2b59b5cb8963a326b4" args="(const sol_solution_t *const pExistingObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request another reference to an existing constant object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A read-only copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="sol__solver_8h.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a>(<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const) </dd>
<dd>
<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByReference(<a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd>
<dd>
void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br/>
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="a344e066d1b42629571d170d47eb268f0"></a><!-- doxytag: member="sol_solver.c::sol_deleteSolution" ref="a344e066d1b42629571d170d47eb268f0" args="(const sol_solution_t *const pConstSolution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_deleteSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a solution object, which had been created by boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstSolution</td><td>The pointer to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeff87ae3d6fca4570e22135642744bc8"></a><!-- doxytag: member="sol_solver.c::sol_getNoIndependents" ref="aeff87ae3d6fca4570e22135642744bc8" args="(const sol_solution_t *const pSolution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoIndependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of independents the solution depends on. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the number of independent quantities. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527fc6c1da24df65513f4036cd909007"></a><!-- doxytag: member="sol_solver.c::sol_getNameOfIndependent" ref="a527fc6c1da24df65513f4036cd909007" args="(const sol_solution_t *const pSolution, unsigned int idxIndependent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfIndependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of an independent quantity of the related solution by index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the independent quantity is returned as read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent. The permitted range can be queried with <em>sol_getNoIndependents</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>unsigned int <a class="el" href="sol__solver_8h.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3aaa4786664dd4ee550cbe77ef1041cd"></a><!-- doxytag: member="sol_solver.c::sol_getNoDependents" ref="a3aaa4786664dd4ee550cbe77ef1041cd" args="(const sol_solution_t *const pSolution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoDependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of dependent quantities, a solution object offers a solution for. This number includes the original unknowns of the LES plus the dependent, user requested unknowns (i.e. user defined voltages). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the number of distinct solutions in this object. This is at the same time the number of dependent quantities and therefore spawns the index range in <em>sol_getNameOfDependent</em>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>const char *sol_getNameOfDependent(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int) </dd></dl>

</div>
</div>
<a class="anchor" id="ac0c1a84b78261db41e91cb0c468d0933"></a><!-- doxytag: member="sol_solver.c::sol_findName" ref="ac0c1a84b78261db41e91cb0c468d0933" args="(const sol_solution_t *const pSolution, signed int *const pIdxSolution, signed int *const pIdxUnknown, signed int *const pIdxUserDefVoltage, signed int *const pIdxKnown, const char *const nameOfQuantity, boolean doErrorReporting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_findName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUnknown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUserDefVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxKnown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>doErrorReporting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Search a solution for a quantity by name, regardless whether it is an original unknown of the LES, a user-defined voltage or a known of the LES. Get either the indexes of an unknown or user defined voltage and the related solution or the index of a known.<br/>
 The combined search is possible since names need to be globally unique, i.e. across the type of an object. The method may also be used to double-check a name for ambiguity.<br/>
 The indexes are returned as signed integers. A value of -1 means that the object is not of that kind.<br/>
 The indexes are returned by reference. Each index result is optional. Pass the NULL pointer if the specific index result is out of interest. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the number of matches. Any number other than 1 indicates a kind of problem. The first match is returned in the index pointers if multiple matches are reported. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
    <tr><td class="paramname">pIdxSolution</td><td>The index of the related solution is placed in * <em>pIdxSolution</em>. </td></tr>
    <tr><td class="paramname">pIdxUnknown</td><td>The index of an unknown would be placed in * <em>pIdxUnknown</em> if <em>nameOfQuantity</em> designates an unknown. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxUserDefVoltage</td><td>The index of a user-defined voltage would be placed in * <em>pIdxUserDefVoltage</em> if <em>nameOfQuantity</em> designates a user-defined unknown voltage. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxKnown</td><td>The index of a known would be placed in * <em>pIdxKnown</em> if <em>nameOfQuantity</em> designates a known. If so, * <em>pIdxSolution</em> is set to -1. </td></tr>
    <tr><td class="paramname">nameOfQuantity</td><td>The known, unknown or user-defined voltage is identified by name. An invalid name will lead to return value 0. </td></tr>
    <tr><td class="paramname">doErrorReporting</td><td>If this flag is set then problems finding the quantity are reported to the global application log. Ambiguous or not matching names are reported. Pass <em>false</em> if the function should indicate these kinds of problems by its return value only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa25eb1220d206469381d3734eb6cef4e"></a><!-- doxytag: member="sol_solver.c::sol_getNameOfDependent" ref="aa25eb1220d206469381d3734eb6cef4e" args="(const sol_solution_t *const pSolution, unsigned int idxSolution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfDependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of an dependent by index of the related solution. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxSolution</td><td>The name of the dependent is returned, which the solution having this index is related to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90202b666b29d26fa9783a53a7f204b1"></a><!-- doxytag: member="sol_solver.c::sol_logSolution" ref="a90202b666b29d26fa9783a53a7f204b1" args="(const sol_solution_t *pSolution, log_logLevel_t logLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_logSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a>&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print the solution of the linear equation system to the global application log. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to print. The object is the result of a successful call of boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </td></tr>
    <tr><td class="paramname">logLevel</td><td>The log level at which the output becomes visible. No output is created if the logger object in use has a higher level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a470f8d09d6a16be38c7ac76067642fc3"></a><!-- doxytag: member="sol_solver.c::_log" ref="a470f8d09d6a16be38c7ac76067642fc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a> <a class="el" href="tbv__table_of_variables_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A global logger object is referenced from anywhere for writing progress messages. </p>

</div>
</div>
<a class="anchor" id="a470a463163890645f09c7b90f2e1de48"></a><!-- doxytag: member="sol_solver.c::_noRefsToObjects" ref="a470a463163890645f09c7b90f2e1de48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="log__logger_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A global counter of all references to any created objects. Used to detect memory leaks. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="sol__solver_8c.html">sol_solver.c</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
