<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>linNet: sol_solver.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8298fcfb537a7f39dcc014d2590e4792.html">linNet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sol_solver.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="smalloc_8h_source.html">smalloc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log__logger_8h_source.html">log_logger.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8h_source.html">coe_coefficient.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8inline_interface_8h_source.html">coe_coefficient.inlineInterface.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="les__linear_equation_system_8h_source.html">les_linearEquationSystem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sol__solver_8h_source.html">sol_solver.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a021b7219e3298775649324ec456a9804"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a021b7219e3298775649324ec456a9804">getVectorOfReqDependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr class="separator:a021b7219e3298775649324ec456a9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc43b8796301c165a786315c5c57d90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aedc43b8796301c165a786315c5c57d90">elementaryStep</a> (<a class="el" href="coe__coefficient_8h.html#a1e6aada7e3a99f08485466793660e7b8">coe_coefMatrix_t</a> A, signed int step, signed int row, signed int col, const <a class="el" href="coe__coefficient_8h.html#aed0d35df49608d13b552b76dbb518871">coe_coef_t</a> *const pKnownDivisor)</td></tr>
<tr class="separator:aedc43b8796301c165a786315c5c57d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff468c335d34a6496b62e994f0f30162"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aff468c335d34a6496b62e994f0f30162">solverLES</a> (<a class="el" href="coe__coefficient_8h.html#a1e6aada7e3a99f08485466793660e7b8">coe_coefMatrix_t</a> A, const unsigned int m, const unsigned int n)</td></tr>
<tr class="separator:aff468c335d34a6496b62e994f0f30162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c5e605e92d71da8ab69fb67c37d8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#ad7c5e605e92d71da8ab69fb67c37d8f9">sol_initModule</a> (<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hLogger)</td></tr>
<tr class="separator:ad7c5e605e92d71da8ab69fb67c37d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3179cdc36acefb42c3e129d4f92bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a2f3179cdc36acefb42c3e129d4f92bed">sol_shutdownModule</a> ()</td></tr>
<tr class="separator:a2f3179cdc36acefb42c3e129d4f92bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25a90cbcbfddb816c292214eb790459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const ppSolution, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES)</td></tr>
<tr class="separator:aa25a90cbcbfddb816c292214eb790459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d81cb47f1e0a03919e32789e78c9074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a8d81cb47f1e0a03919e32789e78c9074">sol_cloneByReference</a> (<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a8d81cb47f1e0a03919e32789e78c9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea66ad9c92eda2b59b5cb8963a326b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a3ea66ad9c92eda2b59b5cb8963a326b4">sol_cloneByConstReference</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a3ea66ad9c92eda2b59b5cb8963a326b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344e066d1b42629571d170d47eb268f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pConstSolution)</td></tr>
<tr class="separator:a344e066d1b42629571d170d47eb268f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff87ae3d6fca4570e22135642744bc8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr class="separator:aeff87ae3d6fca4570e22135642744bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527fc6c1da24df65513f4036cd909007"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a527fc6c1da24df65513f4036cd909007">sol_getNameOfIndependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxIndependent)</td></tr>
<tr class="separator:a527fc6c1da24df65513f4036cd909007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaa4786664dd4ee550cbe77ef1041cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a3aaa4786664dd4ee550cbe77ef1041cd">sol_getNoDependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr class="separator:a3aaa4786664dd4ee550cbe77ef1041cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c1a84b78261db41e91cb0c468d0933"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#ac0c1a84b78261db41e91cb0c468d0933">sol_findName</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, signed int *const pIdxSolution, signed int *const pIdxUnknown, signed int *const pIdxUserDefVoltage, signed int *const pIdxKnown, const char *const nameOfQuantity, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> doErrorReporting)</td></tr>
<tr class="separator:ac0c1a84b78261db41e91cb0c468d0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25eb1220d206469381d3734eb6cef4e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#aa25eb1220d206469381d3734eb6cef4e">sol_getNameOfDependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxSolution)</td></tr>
<tr class="separator:aa25eb1220d206469381d3734eb6cef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90202b666b29d26fa9783a53a7f204b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a90202b666b29d26fa9783a53a7f204b1">sol_logSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *pSolution, <a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a> logLevel)</td></tr>
<tr class="separator:a90202b666b29d26fa9783a53a7f204b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a470f8d09d6a16be38c7ac76067642fc3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = <a class="el" href="log__logger_8h.html#aef9403182a4900c1b62a11082dd7bdb6">LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</a></td></tr>
<tr class="separator:a470f8d09d6a16be38c7ac76067642fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470a463163890645f09c7b90f2e1de48"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0</td></tr>
<tr class="separator:a470a463163890645f09c7b90f2e1de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Symbolic solver for linear equations systems (LES)</p>
<p>Copyright (C) 2013-2014 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a021b7219e3298775649324ec456a9804"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>* getVectorOfReqDependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The set of dependents(i.e. the unknowns of the LES and the user defined voltages), which are required to compute all user defined results is figured out. All unknowns of the LES, which are not in the set don't need to be computed by the solver. The set considers all user-defined results, which may directly refer to unknowns of the LES but also indirectly by referencing user-defined voltages. </p>
<dl class="section return"><dt>Returns</dt><dd>The set is returned as an ordered vector of Boolean, where element <em>i</em> of the vector relates to unknown <em>i</em> of the LES, if <em>i</em> is lower then the number <em>n</em> of unknowns. Otherwise element <em>i</em> refers to user defined voltage <em>i</em> - <em>n</em>. The related dependent is required if the element is <em>true</em>.<br/>
 The returned vector is malloc allocated and needs to be freed after use. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. If called during object construction: The table of variables and the circuit net list need to be setup before this function may be called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedc43b8796301c165a786315c5c57d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void elementaryStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coe__coefficient_8h.html#a1e6aada7e3a99f08485466793660e7b8">coe_coefMatrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="coe__coefficient_8h.html#aed0d35df49608d13b552b76dbb518871">coe_coef_t</a> *const&#160;</td>
          <td class="paramname"><em>pKnownDivisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The most basic operation of the extended Gauss elimination. It re-computes one coefficient of the LES according to: A(m,n)=(A(m,n)*A(step,step)-A(step,n)*A(m,step))/t. The extension of the known Gauss elimination is the specification of t, which is a known divisor; the division can be carried out without a remainder. Normally the Gauss elimination is defined for algebraic structure of kind field; because of the divisor we can apply it to the simpler ring.<br/>
 Here, the elementary step is implemented for linear combinations having products of symbols as coefficients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix of coefficients, which are manipulated in place. The result is returned in place. </td></tr>
    <tr><td class="paramname">step</td><td>The elimination step of the Gauss elimination. In fact, step+i, i = 1..m-step-1, are the indexes of the equations which are manipulated to get another leading null coefficient. </td></tr>
    <tr><td class="paramname">row</td><td>The row index of the coefficient under operation. </td></tr>
    <tr><td class="paramname">col</td><td>The column index of the coefficient under operation. </td></tr>
    <tr><td class="paramname">pKnownDivisor</td><td>The known divisor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff468c335d34a6496b62e994f0f30162"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> solverLES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coe__coefficient_8h.html#a1e6aada7e3a99f08485466793660e7b8">coe_coefMatrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The solver for a linear equation system.<br/>
 The system is solved by the modified Gaussian elimination method. The required algebraic structure the coefficients belongs to is less demanding than for the original elimination: The division is not required. The modified elimination can e.g. be performed with integer numbers. The coefficients' algebraic structure needs to have the sum and the multiplication operation.<br/>
 The arithmetic is not done in this routine; it only implements the control structure. The algebraic operations on the coefficients are solely done in the sub-routine elementaryOperation. By exchanging this sub-routine the solver could be used for other sets of coefficients.<br/>
 A possible impact of the actual arithmetics on the control structure in this routine could be a round off error of the multiplikation operation. True pivoting could become an issue. The current implementation of the control structure just implements a simple pivoting, which suffices for error-free sum and multiplication. </p>
<dl class="section return"><dt>Returns</dt><dd>The function returns true if the LES could be solved. false ii e.g. returned in case of linearly dependent equations. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The array of coefficients, which are manipulated in place. The result is returned in place.<br/>
 The array is organized as m rows and n columns, where n &gt;= m+1. The rectangular area A[0..m-1][0..m-1] holds the coefficients belonging to the m unknowns. If the algorithm returns true than this area is a diagonal matrix, where A[i][i], i=0..m-1, holds the denominator of the solution for unknown i.<br/>
 A[0..m-1][m..n-1] holds the left hand side of the LES (where the sign of these coefficients is such that the sum of all row elements becomes null). Column i, i=m..n-1, holds the coefficients belonging to the known input variable i-m. If the algorithm returns true than this area contains the numerators of the solution. A[i][j+m]*V_j, i=0..m-1, j=0..n-m-1, is the complete numerator of the result for unknown i. </td></tr>
    <tr><td class="paramname">m</td><td>The number <em>m</em> of rows of the matrix <em>A</em>. </td></tr>
    <tr><td class="paramname">n</td><td>The number <em>n</em> of columns of the matrix <em>A</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>void elementaryStep(coe_coefMatrix_t, int, int, int, coe_coef_t *) </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c5e605e92d71da8ab69fb67c37d8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module at application startup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="sol__solver_8c.html#a2f3179cdc36acefb42c3e129d4f92bed">sol_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2f3179cdc36acefb42c3e129d4f92bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="aa25a90cbcbfddb816c292214eb790459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> sol_createSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const&#160;</td>
          <td class="paramname"><em>ppSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The complete solution of a LES is figured out and returned as a new object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the operation entirely succeeded. Otherwise the function returns false and appropriate error messages have been written to the global application log. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppSolution</td><td>The pointer to the new object is returned in * <em>ppSolution</em>. The solution object can be used to report the result of the LES or for further processing (like numeric evaluation). Do not use * <em>ppSolution</em> if the function returns false. </td></tr>
    <tr><td class="paramname">pLES</td><td>The LES is passed by reference. The passed object is the successful result of les_createLES. * <em>pLES</em> may be deleted after return of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d81cb47f1e0a03919e32789e78c9074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request another reference to an existing object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByConstReference(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea66ad9c92eda2b59b5cb8963a326b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request another reference to an existing constant object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A read-only copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="sol__solver_8h.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a>(<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const) </dd>
<dd>
<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByReference(<a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd>
<dd>
void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br/>
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="a344e066d1b42629571d170d47eb268f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_deleteSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a solution object, which had been created by boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstSolution</td><td>The pointer to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeff87ae3d6fca4570e22135642744bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoIndependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of independents the solution depends on. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of independent quantities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527fc6c1da24df65513f4036cd909007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfIndependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of an independent quantity of the related solution by index. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the independent quantity is returned as read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent. The permitted range can be queried with <em>sol_getNoIndependents</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>unsigned int <a class="el" href="sol__solver_8h.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3aaa4786664dd4ee550cbe77ef1041cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoDependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of dependent quantities, a solution object offers a solution for. This number includes the original unknowns of the LES plus the dependent, user requested unknowns (i.e. user defined voltages). </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of distinct solutions in this object. This is at the same time the number of dependent quantities and therefore spawns the index range in <em>sol_getNameOfDependent</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>const char *sol_getNameOfDependent(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int) </dd></dl>

</div>
</div>
<a class="anchor" id="ac0c1a84b78261db41e91cb0c468d0933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_findName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUnknown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUserDefVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxKnown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>doErrorReporting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a solution for a quantity by name, regardless whether it is an original unknown of the LES, a user-defined voltage or a known of the LES. Get either the indexes of an unknown or user defined voltage and the related solution or the index of a known.<br/>
 The combined search is possible since names need to be globally unique, i.e. across the type of an object. The method may also be used to double-check a name for ambiguity.<br/>
 The indexes are returned as signed integers. A value of -1 means that the object is not of that kind.<br/>
 The indexes are returned by reference. Each index result is optional. Pass the NULL pointer if the specific index result is out of interest. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of matches. Any number other than 1 indicates a kind of problem. The first match is returned in the index pointers if multiple matches are reported. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
    <tr><td class="paramname">pIdxSolution</td><td>The index of the related solution is placed in * <em>pIdxSolution</em>. </td></tr>
    <tr><td class="paramname">pIdxUnknown</td><td>The index of an unknown would be placed in * <em>pIdxUnknown</em> if <em>nameOfQuantity</em> designates an unknown. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxUserDefVoltage</td><td>The index of a user-defined voltage would be placed in * <em>pIdxUserDefVoltage</em> if <em>nameOfQuantity</em> designates a user-defined unknown voltage. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxKnown</td><td>The index of a known would be placed in * <em>pIdxKnown</em> if <em>nameOfQuantity</em> designates a known. If so, * <em>pIdxSolution</em> is set to -1. </td></tr>
    <tr><td class="paramname">nameOfQuantity</td><td>The known, unknown or user-defined voltage is identified by name. An invalid name will lead to return value 0. </td></tr>
    <tr><td class="paramname">doErrorReporting</td><td>If this flag is set then problems finding the quantity are reported to the global application log. Ambiguous or not matching names are reported. Pass <em>false</em> if the function should indicate these kinds of problems by its return value only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa25eb1220d206469381d3734eb6cef4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfDependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of an dependent by index of the related solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxSolution</td><td>The name of the dependent is returned, which the solution having this index is related to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90202b666b29d26fa9783a53a7f204b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_logSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a>&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the solution of the linear equation system to the global application log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to print. The object is the result of a successful call of boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </td></tr>
    <tr><td class="paramname">logLevel</td><td>The log level at which the output becomes visible. No output is created if the logger object in use has a higher level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a470f8d09d6a16be38c7ac76067642fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> _log = <a class="el" href="log__logger_8h.html#aef9403182a4900c1b62a11082dd7bdb6">LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global logger object is referenced from anywhere for writing progress messages. </p>

</div>
</div>
<a class="anchor" id="a470a463163890645f09c7b90f2e1de48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _noRefsToObjects = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global counter of all references to any created objects. Used to detect memory leaks. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 23 2014 10:40:27 for linNet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
