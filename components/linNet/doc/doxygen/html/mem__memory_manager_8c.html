<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: mem_memoryManager.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('mem__memory_manager_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>mem_memoryManager.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;types.h&quot;</code><br/>
<code>#include &quot;smalloc.h&quot;</code><br/>
<code>#include &quot;log_logger.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem__memory_manager_8h_source.html">mem_memoryManager.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a7cacad20d6b80fb709017953a80f3ed1">COMMON_MACHINE_ALIGNMENT</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#af0963639bca9093157f766e33ef71d4a">SIZEOF_ALIGNED</a>(s)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _memChunk_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a1cba779e33b93911f41562b06f5555a4">memChunk_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct mem_heap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#aaab6f5bb1be0dc66881377748dc756cd">debug_checkConsistency</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#abf957af29856e4d471bf26bf8ecc81a8">allocNewChunk</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *const pHeap, unsigned int noDataObjs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="mem__memory_manager_8h.html#aeacb2c05257cf2640d30be458abb4f99">mem_hHeap_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a1bc4de9106acae1c38f5a9262126f98b">mem_createHeap</a> (<a class="el" href="structlog__logger__t.html">log_hLogger_t</a> hLogger, const char *name, size_t sizeOfDataObjects, unsigned int initialHeapSize, unsigned int allocationBlockSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a69149f83a83357b46e72863edbdc64c4">mem_deleteHeap</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> warnIfUnfreedMem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a6b84b799baa9e000db9410b882c5ef67">mem_malloc</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a4869c36173c9d53f33734f8480d12acc">mem_mallocList</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap, unsigned int lenOfList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#a0def23182a64f28d82a7c9c1937f3de1">mem_free</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap, void *pDataObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__memory_manager_8c.html#ab6449c17302dca5134f33a97ac646e58">mem_freeList</a> (<a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *pHeap, void *pHeadOfList)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This module implements a simple but very fast and stable memory management. It uses the free-list algorithm: A pre-defined number of memory blocks is organized as a linked list. Requested elements are taken from the head of the list and returned elements are added in front of this list. The algorithm is free of fragmentation or variable run-time issues but can be applied to elements of same size only. Therefore, the interface permitts to create the memory management as an object. An application may create such an object for each type of object, where the high performance of this implementation in comparison to the general purpose heap malloc/free is essential.<br/>
 To further increase the performance for applictions, which heavily deal with linked lists, it has decided to make the free-list structure identical to the client's list structure, i.e. the element linking pointer is the same inside the memory management and at the application side. The element handling can't be done typesafe in C as a memory manager can be instatiated for data objects of different data types. Taking both considerations into repect an important constraint on the handled data objects can be derived:<br/>
 The handled data objects must reserve the space for a pointer at the base address of the handled data objects. This pointer is used by the memory management to link the free elements in the heap.<br/>
 However, a client, who wants to implement linked lists using the memory management may use this pointer for its own list-linking purpose. In this case he can request a linked list of n elements from the memory management at once and he can free a linked list of data objects at once.<br/>
 All handling of data objects in this module is done typeless and based on void pointers. Therefore a run-time type check is strongly recommended. Please add some code like </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #include &lt;assert.h&gt;</span>

   <span class="keyword">typedef</span> <span class="keyword">struct </span>mydataObj_t {
      mydataObj_s *myListLink; <span class="comment">// This needs to be the first member!</span>
      ... myOtherDataObjMembers;
   } myDataObj_t;

   <span class="keywordtype">int</span> <a class="code" href="lin__lin_net_8c.html#a9bfc2ded38cb3643d458581adb77200b">main</a>() {
<span class="preprocessor">   #ifdef DEBUG</span>
<span class="preprocessor"></span>      myDataObj_t dummyObj;
      assert((<span class="keywordtype">char</span>*)&amp;dummyObj.myListLink == (<span class="keywordtype">char</span>*)&amp;dummyObj + <a class="code" href="mem__memory_manager_8h.html#a839133e1cdd5cdcaa2317d072ae06348">MEM_OFFSET_OF_LINK_POINTER</a>
             &amp;&amp;  <span class="keyword">sizeof</span>(dummyObj.myListLink) == <a class="code" href="mem__memory_manager_8h.html#a20e73ebaf7dcee069968a1000150c362">MEM_SIZE_OF_LINK_POINTER</a>
            );
<span class="preprocessor">   #endif</span>
<span class="preprocessor">   }</span>
</pre></div><p> to your application. If your application doesn't operate on linked lists, you'd probably change the definition of member myListLink to something like void *pReserved. The suggested self-test of the code should still be present.<br/>
 The memory manager allocates the memory, which it partitions and manages in linked lists of data objects, in large chunks from the general purpose heap using malloc. A new chunk is allocated whenever the free list is exhausted. These chunks are not freed again unless you delete the complete memory manager.<br/>
 There's no error handling strategy. As long as the general purpose heap provides memory the allocation of data objects or lists of such will never fail, but if there's no system memory left, the error handling simply is the abortion of the application after writing an error message to stderr.</p>
<p>Copyright (C) 2013 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7cacad20d6b80fb709017953a80f3ed1"></a><!-- doxytag: member="mem_memoryManager.c::COMMON_MACHINE_ALIGNMENT" ref="a7cacad20d6b80fb709017953a80f3ed1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMMON_MACHINE_ALIGNMENT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The implemented algorithm handles all actual data elements by void*. Specify an alignment, which will be suitable for possible actual elements, which are going to be stored in the allocated memory blocks. </p>

</div>
</div>
<a class="anchor" id="af0963639bca9093157f766e33ef71d4a"></a><!-- doxytag: member="mem_memoryManager.c::SIZEOF_ALIGNED" ref="af0963639bca9093157f766e33ef71d4a" args="(s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIZEOF_ALIGNED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((s)+(<a class="code" href="mem__memory_manager_8c.html#a7cacad20d6b80fb709017953a80f3ed1">COMMON_MACHINE_ALIGNMENT</a>)-1) / (<a class="code" href="mem__memory_manager_8c.html#a7cacad20d6b80fb709017953a80f3ed1">COMMON_MACHINE_ALIGNMENT</a>)  \
                           * (<a class="code" href="mem__memory_manager_8c.html#a7cacad20d6b80fb709017953a80f3ed1">COMMON_MACHINE_ALIGNMENT</a>)                                     \
                          )
</pre></div><p>The data elements the heap is partitioned in basically have the size of the client's data objects, but they are enlarged so that sub-sequent elements will all be on an aligned address. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a1cba779e33b93911f41562b06f5555a4"></a><!-- doxytag: member="mem_memoryManager.c::memChunk_t" ref="a1cba779e33b93911f41562b06f5555a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _memChunk_t  <a class="el" href="mem__memory_manager_8c.html#a1cba779e33b93911f41562b06f5555a4">memChunk_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The definition of a single chunk of heap memory. </p>

</div>
</div>
<a class="anchor" id="a28ec492101a89fafceb6a6b0febf54cb"></a><!-- doxytag: member="mem_memoryManager.c::heap_t" ref="a28ec492101a89fafceb6a6b0febf54cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mem_heap_t  <a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The definition of a memory manager object. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aaab6f5bb1be0dc66881377748dc756cd"></a><!-- doxytag: member="mem_memoryManager.c::debug_checkConsistency" ref="aaab6f5bb1be0dc66881377748dc756cd" args="(heap_t *pHeap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void debug_checkConsistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Self-test function: Check consistency of heap data structure. The test result is reported by assertion. The code is used and available only for debug compilation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The pointer to the heap under test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf957af29856e4d471bf26bf8ecc81a8"></a><!-- doxytag: member="mem_memoryManager.c::allocNewChunk" ref="abf957af29856e4d471bf26bf8ecc81a8" args="(heap_t *const pHeap, unsigned int noDataObjs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void allocNewChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *const&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noDataObjs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new chunk to the (exhausted) heap and partition its for allocation request by the heap's client. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The pointer to the heap under progress. </td></tr>
    <tr><td class="paramname">noDataObjs</td><td>The size of the new chunk in number of data objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bc4de9106acae1c38f5a9262126f98b"></a><!-- doxytag: member="mem_memoryManager.c::mem_createHeap" ref="a1bc4de9106acae1c38f5a9262126f98b" args="(log_hLogger_t hLogger, const char *name, size_t sizeOfDataObjects, unsigned int initialHeapSize, unsigned int allocationBlockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mem__memory_manager_8h.html#aeacb2c05257cf2640d30be458abb4f99">mem_hHeap_t</a> mem_createHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__logger__t.html">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeOfDataObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initialHeapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>allocationBlockSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a heap for specific (list) elements. </p>

</div>
</div>
<a class="anchor" id="a69149f83a83357b46e72863edbdc64c4"></a><!-- doxytag: member="mem_memoryManager.c::mem_deleteHeap" ref="a69149f83a83357b46e72863edbdc64c4" args="(heap_t *pHeap, boolean warnIfUnfreedMem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long mem_deleteHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>warnIfUnfreedMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a heap. All references to currently allocated data objects become invalid and must no longer be used. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of still allocated data objects is returned, i.e. data objects on the heap, which had not been freed before deletion of heap. Normally it is an error in the client application if this value is not equal to zero. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The handle to the heap as got from mem_createHeap. </td></tr>
    <tr><td class="paramname">warnIfUnfreedMem</td><td>If true, a warning is written to the logger if un-freed elements exit, i.e. when the function returns a non null value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b84b799baa9e000db9410b882c5ef67"></a><!-- doxytag: member="mem_memoryManager.c::mem_malloc" ref="a6b84b799baa9e000db9410b882c5ef67" args="(heap_t *pHeap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mem_malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a single data object on the heap. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the data object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The handle to the heap as got from mem_createHeap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4869c36173c9d53f33734f8480d12acc"></a><!-- doxytag: member="mem_memoryManager.c::mem_mallocList" ref="a4869c36173c9d53f33734f8480d12acc" args="(heap_t *pHeap, unsigned int lenOfList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mem_mallocList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lenOfList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a linked list of data objects on the heap. This operation is useful and defined only if the client knows and respects that the first bytes of the allocated data objects contain a pointer to the next allocated data object and so on. The client can access the sequence of returned, allocated data objects only this way, he must not consider the returned data an array of n elements! </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the head of the returned list, i.e. to the first data object in the list. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The handle to the heap as got from mem_createHeap. </td></tr>
    <tr><td class="paramname">lenOfList</td><td>The length of the list, i.e. the number of linked data objects. lenOfList is greater than 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The client may disregard and overwrite the link pointer in the first data bytes of each returned data element if he's not going to return the list or parts of it with the counterpart function void *mem_freeList(heap_t *), but if he instead will return each element separately using the function void *mem_free(heap_t *). </dd></dl>

</div>
</div>
<a class="anchor" id="a0def23182a64f28d82a7c9c1937f3de1"></a><!-- doxytag: member="mem_memoryManager.c::mem_free" ref="a0def23182a64f28d82a7c9c1937f3de1" args="(heap_t *pHeap, void *pDataObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mem_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDataObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a no longer used data object to the heap it was allocated on before. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The handle to the heap the data object belongs to. </td></tr>
    <tr><td class="paramname">pDataObj</td><td>The pointer to the data object, which is returned to the heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6449c17302dca5134f33a97ac646e58"></a><!-- doxytag: member="mem_memoryManager.c::mem_freeList" ref="ab6449c17302dca5134f33a97ac646e58" args="(heap_t *pHeap, void *pHeadOfList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mem_freeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem__memory_manager_8c.html#a28ec492101a89fafceb6a6b0febf54cb">heap_t</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pHeadOfList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a linked list of no longer used data objects to the heap they were allocated on before.<br/>
 Caution, this function will work only if the client is fully aware of the data object link pointer in the first bytes of each data object and if he respects and uses the pointers in this way. All returned objects have to be linked by this pointer and the link pointer of the last one needs to be NULL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>The handle to the heap the data objects belongs to. </td></tr>
    <tr><td class="paramname">pHeadOfList</td><td>The pointer to the head of the list that is returned to the heap, i.e. the first one of the linked data objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="mem__memory_manager_8c.html">mem_memoryManager.c</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
