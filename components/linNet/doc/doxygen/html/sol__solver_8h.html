<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>linNet: sol_solver.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8298fcfb537a7f39dcc014d2590e4792.html">linNet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sol_solver.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="log__logger_8h_source.html">log_logger.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="coe__coefficient_8h_source.html">coe_coefficient.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tbv__table_of_variables_8h_source.html">tbv_tableOfVariables.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="les__linear_equation_system_8h_source.html">les_linearEquationSystem.h</a>&quot;</code><br/>
</div>
<p><a href="sol__solver_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsol__solution__t.html">sol_solution_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adeaf5ba517bffd604de6fdfc74c8023d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsol__solution__t.html">sol_solution_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#adeaf5ba517bffd604de6fdfc74c8023d">sol_solution_t</a></td></tr>
<tr class="separator:adeaf5ba517bffd604de6fdfc74c8023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa7e7f7e95e966ed03adc64b923283d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#aa7e7f7e95e966ed03adc64b923283d11">sol_initModule</a> (<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hGlobalLogger)</td></tr>
<tr class="separator:aa7e7f7e95e966ed03adc64b923283d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9cc92c8b205bffd9e34f024f86dc02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#aac9cc92c8b205bffd9e34f024f86dc02">sol_shutdownModule</a> (void)</td></tr>
<tr class="separator:aac9cc92c8b205bffd9e34f024f86dc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25a90cbcbfddb816c292214eb790459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const ppSolution, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const pLES)</td></tr>
<tr class="separator:aa25a90cbcbfddb816c292214eb790459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d81cb47f1e0a03919e32789e78c9074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a8d81cb47f1e0a03919e32789e78c9074">sol_cloneByReference</a> (<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a8d81cb47f1e0a03919e32789e78c9074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea66ad9c92eda2b59b5cb8963a326b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a3ea66ad9c92eda2b59b5cb8963a326b4">sol_cloneByConstReference</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a3ea66ad9c92eda2b59b5cb8963a326b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344e066d1b42629571d170d47eb268f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pConstSolution)</td></tr>
<tr class="separator:a344e066d1b42629571d170d47eb268f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff87ae3d6fca4570e22135642744bc8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr class="separator:aeff87ae3d6fca4570e22135642744bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527fc6c1da24df65513f4036cd909007"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a527fc6c1da24df65513f4036cd909007">sol_getNameOfIndependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxIndependent)</td></tr>
<tr class="separator:a527fc6c1da24df65513f4036cd909007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaa4786664dd4ee550cbe77ef1041cd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a3aaa4786664dd4ee550cbe77ef1041cd">sol_getNoDependents</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution)</td></tr>
<tr class="separator:a3aaa4786664dd4ee550cbe77ef1041cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054bed03caef17dfc398dd6d5b24999f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a054bed03caef17dfc398dd6d5b24999f">sol_getNameOfDependent</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, unsigned int idxDependent)</td></tr>
<tr class="separator:a054bed03caef17dfc398dd6d5b24999f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c1a84b78261db41e91cb0c468d0933"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#ac0c1a84b78261db41e91cb0c468d0933">sol_findName</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pSolution, signed int *const pIdxSolution, signed int *const pIdxUnknown, signed int *const pIdxUserDefVoltage, signed int *const pIdxKnown, const char *const nameOfQuantity, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> doErrorReporting)</td></tr>
<tr class="separator:ac0c1a84b78261db41e91cb0c468d0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90202b666b29d26fa9783a53a7f204b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sol__solver_8h.html#a90202b666b29d26fa9783a53a7f204b1">sol_logSolution</a> (const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *pSolution, <a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a> logLevel)</td></tr>
<tr class="separator:a90202b666b29d26fa9783a53a7f204b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of global interface of module <a class="el" href="sol__solver_8c.html">sol_solver.c</a></p>
<p>Copyright (C) 2013-2014 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adeaf5ba517bffd604de6fdfc74c8023d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsol__solution__t.html">sol_solution_t</a>  <a class="el" href="structsol__solution__t.html">sol_solution_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The solution object contains the complete symbolic solution of the LES. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa7e7f7e95e966ed03adc64b923283d11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module prior to first use of any of its methods or global data objects.</p>
<p>Initialize the module at application startup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="sol__solver_8c.html#a2f3179cdc36acefb42c3e129d4f92bed">sol_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac9cc92c8b205bffd9e34f024f86dc02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown of module after use. Release of memory, closing files, etc.</p>
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="aa25a90cbcbfddb816c292214eb790459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> sol_createSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> **const&#160;</td>
          <td class="paramname"><em>ppSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pLES</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the solution of a LES and return it as a dedicated object.</p>
<p>The complete solution of a LES is figured out and returned as a new object. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the operation entirely succeeded. Otherwise the function returns false and appropriate error messages have been written to the global application log. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppSolution</td><td>The pointer to the new object is returned in * <em>ppSolution</em>. The solution object can be used to report the result of the LES or for further processing (like numeric evaluation). Do not use * <em>ppSolution</em> if the function returns false. </td></tr>
    <tr><td class="paramname">pLES</td><td>The LES is passed by reference. The passed object is the successful result of les_createLES. * <em>pLES</em> may be deleted after return of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8d81cb47f1e0a03919e32789e78c9074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get another reference to an existing object.</p>
<p>Request another reference to an existing object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByConstReference(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea66ad9c92eda2b59b5cb8963a326b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a>* sol_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get another reference to an existing constant object.</p>
<p>Request another reference to an existing constant object. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with <em>sol_deleteSolution</em> after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A read-only copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="sol__solver_8h.html#aa25a90cbcbfddb816c292214eb790459">sol_createSolution</a>(<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const) </dd>
<dd>
<a class="el" href="structsol__solution__t.html">sol_solution_t</a> *sol_cloneByReference(<a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const) </dd>
<dd>
void <a class="el" href="sol__solver_8h.html#a344e066d1b42629571d170d47eb268f0">sol_deleteSolution(const sol_solution_t * const)</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br/>
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="a344e066d1b42629571d170d47eb268f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_deleteSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a solution object as got from sol_createSolution.</p>
<p>Delete a solution object, which had been created by boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstSolution</td><td>The pointer to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeff87ae3d6fca4570e22135642744bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoIndependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of unknowns, i.e. of independent quantities, a solution object offers a solution for.</p>
<p>Get the number of independents the solution depends on. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of independent quantities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a527fc6c1da24df65513f4036cd909007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfIndependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a known by index of the related solution.</p>
<p>Get the name of an independent quantity of the related solution by index. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the independent quantity is returned as read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent. The permitted range can be queried with <em>sol_getNoIndependents</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>unsigned int <a class="el" href="sol__solver_8h.html#aeff87ae3d6fca4570e22135642744bc8">sol_getNoIndependents(const sol_solution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3aaa4786664dd4ee550cbe77ef1041cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_getNoDependents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of unknowns, a solution object offers a solution for.</p>
<p>Get the number of dependent quantities, a solution object offers a solution for. This number includes the original unknowns of the LES plus the dependent, user requested unknowns (i.e. user defined voltages). </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of distinct solutions in this object. This is at the same time the number of dependent quantities and therefore spawns the index range in <em>sol_getNameOfDependent</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>const char *sol_getNameOfDependent(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int) </dd></dl>

</div>
</div>
<a class="anchor" id="a054bed03caef17dfc398dd6d5b24999f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sol_getNameOfDependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxSolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a dependent quantity by index.</p>
<p>Get the name of an dependent by index of the related solution. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the read-only string. The character pointer points into the solution object and is valid as long as this object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution. </td></tr>
    <tr><td class="paramname">idxSolution</td><td>The name of the dependent is returned, which the solution having this index is related to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0c1a84b78261db41e91cb0c468d0933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sol_findName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUnknown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxUserDefVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int *const&#160;</td>
          <td class="paramname"><em>pIdxKnown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfQuantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>doErrorReporting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search the solution for a quantity by name (an original unknown of the LES, a user-defined voltage or a known of the LES).</p>
<p>Search a solution for a quantity by name, regardless whether it is an original unknown of the LES, a user-defined voltage or a known of the LES. Get either the indexes of an unknown or user defined voltage and the related solution or the index of a known.<br/>
 The combined search is possible since names need to be globally unique, i.e. across the type of an object. The method may also be used to double-check a name for ambiguity.<br/>
 The indexes are returned as signed integers. A value of -1 means that the object is not of that kind.<br/>
 The indexes are returned by reference. Each index result is optional. Pass the NULL pointer if the specific index result is out of interest. </p>
<dl class="section return"><dt>Returns</dt><dd>Get the number of matches. Any number other than 1 indicates a kind of problem. The first match is returned in the index pointers if multiple matches are reported. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Pass the solution object by reference. </td></tr>
    <tr><td class="paramname">pIdxSolution</td><td>The index of the related solution is placed in * <em>pIdxSolution</em>. </td></tr>
    <tr><td class="paramname">pIdxUnknown</td><td>The index of an unknown would be placed in * <em>pIdxUnknown</em> if <em>nameOfQuantity</em> designates an unknown. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxUserDefVoltage</td><td>The index of a user-defined voltage would be placed in * <em>pIdxUserDefVoltage</em> if <em>nameOfQuantity</em> designates a user-defined unknown voltage. If so, * <em>pIdxSolution</em> is also set. </td></tr>
    <tr><td class="paramname">pIdxKnown</td><td>The index of a known would be placed in * <em>pIdxKnown</em> if <em>nameOfQuantity</em> designates a known. If so, * <em>pIdxSolution</em> is set to -1. </td></tr>
    <tr><td class="paramname">nameOfQuantity</td><td>The known, unknown or user-defined voltage is identified by name. An invalid name will lead to return value 0. </td></tr>
    <tr><td class="paramname">doErrorReporting</td><td>If this flag is set then problems finding the quantity are reported to the global application log. Ambiguous or not matching names are reported. Pass <em>false</em> if the function should indicate these kinds of problems by its return value only. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90202b666b29d26fa9783a53a7f204b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sol_logSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a>&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a complete solution to the application log.</p>
<p>Print the solution of the linear equation system to the global application log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to print. The object is the result of a successful call of boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). </td></tr>
    <tr><td class="paramname">logLevel</td><td>The log level at which the output becomes visible. No output is created if the logger object in use has a higher level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 23 2014 10:40:27 for linNet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
