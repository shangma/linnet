<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>linNet: tbv_tableOfVariables.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tbv__table_of_variables_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tbv_tableOfVariables.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log__logger_8h_source.html">log_logger.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rat__rational_number_8h_source.html">rat_rationalNumber.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pci__parser_circuit_8h_source.html">pci_parserCircuit.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="coe__coefficient_8h_source.html">coe_coefficient.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="msc__m_script_8h_source.html">msc_mScript.h</a>&quot;</code><br />
</div>
<p><a href="tbv__table_of_variables_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbv__known_variable__t.html">tbv_knownVariable_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a21f7f75f4a3b2f2496684f816b95318a"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak" />
<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a21f7f75f4a3b2f2496684f816b95318a">tbv_tableOfVariables_t</a></td></tr>
<tr class="separator:a21f7f75f4a3b2f2496684f816b95318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2c0e5fe28a9d36ad30d1555426db8b59"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a> { <br />
&#160;&#160;<a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59ab5c40e0f083a1771ab2f641d634a1357">tbv_assignDefaultValues</a>, 
<br />
&#160;&#160;<a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59a9940e0d1019893710258924e2c4d9662">tbv_assignParameterStruct</a>, 
<br />
&#160;&#160;<a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59af581c27993afaa229ecbff5eacd09462">tbv_copyToParameterStruct</a>
<br />
 }</td></tr>
<tr class="separator:a2c0e5fe28a9d36ad30d1555426db8b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0c36afe5d520e1f4076c6ea4ddc7884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#ac0c36afe5d520e1f4076c6ea4ddc7884">tbv_initModule</a> (<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hGlobalLogger)</td></tr>
<tr class="separator:ac0c36afe5d520e1f4076c6ea4ddc7884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab9ab3c84ad4e09d8ee596658669fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a1ab9ab3c84ad4e09d8ee596658669fd6">tbv_shutdownModule</a> (void)</td></tr>
<tr class="separator:a1ab9ab3c84ad4e09d8ee596658669fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289cade8d2f18e3e4e9a01027fabe0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a289cade8d2f18e3e4e9a01027fabe0b7">tbv_createTableOfVariables</a> (unsigned int noKnowns, unsigned int noUnknowns, unsigned int noConstants, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pCircuitNetList)</td></tr>
<tr class="separator:a289cade8d2f18e3e4e9a01027fabe0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1e84d24e0c14aa68e97d2fb5b4d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a5de1e84d24e0c14aa68e97d2fb5b4d6c">tbv_cloneByShallowCopy</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a5de1e84d24e0c14aa68e97d2fb5b4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74786ef478ab7dbe6cde4a62fddc26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#abf74786ef478ab7dbe6cde4a62fddc26">tbv_cloneByReference</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTabOfVars)</td></tr>
<tr class="separator:abf74786ef478ab7dbe6cde4a62fddc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6381ee040e21d959be597981e152160e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a6381ee040e21d959be597981e152160e">tbv_cloneByConstReference</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTabOfVars)</td></tr>
<tr class="separator:a6381ee040e21d959be597981e152160e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7eff6ae0630047d542fcb7c579188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#adcc7eff6ae0630047d542fcb7c579188">tbv_deleteTableOfVariables</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTabOfVars)</td></tr>
<tr class="separator:adcc7eff6ae0630047d542fcb7c579188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c7acab587bdb54bc76761b43edc856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a23c7acab587bdb54bc76761b43edc856">tbv_logTableOfVariables</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable)</td></tr>
<tr class="separator:a23c7acab587bdb54bc76761b43edc856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e47b2021631fb5761160ee8c830f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a86e47b2021631fb5761160ee8c830f51">tbv_addKnown</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const name, unsigned int idxDevice)</td></tr>
<tr class="separator:a86e47b2021631fb5761160ee8c830f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab192c8d6735625c9771afdb7156cd621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#ab192c8d6735625c9771afdb7156cd621">tbv_addUnknown</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const name, unsigned int idxNode, unsigned int idxSubNet, unsigned int idxDevice)</td></tr>
<tr class="separator:ab192c8d6735625c9771afdb7156cd621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03935de59128a8b5b0950295b123b581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a03935de59128a8b5b0950295b123b581">tbv_addConstant</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a03935de59128a8b5b0950295b123b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d90b517ec9c3808eb5d6e02a208b0f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a6d90b517ec9c3808eb5d6e02a208b0f2">tbv_sortConstants</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable)</td></tr>
<tr class="separator:a6d90b517ec9c3808eb5d6e02a208b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b3d754a0695ee117defd72a4db8921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a82b3d754a0695ee117defd72a4db8921">tbv_exportAsMCode</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, <a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const pMScript, <a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a> context, const char *const indentStr)</td></tr>
<tr class="separator:a82b3d754a0695ee117defd72a4db8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1bac7852f707dc27fa1b9055d7c0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__known_variable__t.html">tbv_knownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a26f1bac7852f707dc27fa1b9055d7c0a">tbv_getKnownByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a26f1bac7852f707dc27fa1b9055d7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e9acc910c1dee86990e7087ba7e53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a738e9acc910c1dee86990e7087ba7e53">tbv_getUnknownByNode</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxNode)</td></tr>
<tr class="separator:a738e9acc910c1dee86990e7087ba7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7162b1123ba15a3eed6367c8733dc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a7c7162b1123ba15a3eed6367c8733dc8">tbv_getUnknownByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a7c7162b1123ba15a3eed6367c8733dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe5c8471002f477b82b2eada152b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coe__coefficient_8h.html#a53d35044911ab7bc1121b47d22e7e82c">coe_productOfConst_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a84fe5c8471002f477b82b2eada152b34">tbv_getConstantByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a84fe5c8471002f477b82b2eada152b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d2f95cc4204f07dabe345b936d0d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpci__device__t.html">pci_device_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a579d2f95cc4204f07dabe345b936d0d4">tbv_getDeviceByBitIndex</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxBit)</td></tr>
<tr class="separator:a579d2f95cc4204f07dabe345b936d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891cb33e9396da854317282fad2eb7f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#a891cb33e9396da854317282fad2eb7f7">tbv_getReferencedDeviceByBitIndex</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, <a class="el" href="structrat__num__t.html">rat_num_t</a> *pRefFactor, const <a class="el" href="structpci__device__t.html">pci_device_t</a> **const ppDevice, unsigned int *pIdxBitRefDev, unsigned int idxBit)</td></tr>
<tr class="separator:a891cb33e9396da854317282fad2eb7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7811ea00b8c3715e2b14d5ef5eacb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8h.html#af1b7811ea00b8c3715e2b14d5ef5eacb">tbv_setTargetUnknownForSolver</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const nameOfUnknown)</td></tr>
<tr class="separator:af1b7811ea00b8c3715e2b14d5ef5eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of global interface of module <a class="el" href="tbv__table_of_variables_8c.html">tbv_tableOfVariables.c</a></p>
<p>Copyright (C) 2013 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a21f7f75f4a3b2f2496684f816b95318a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>  <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A data structure, that holds lists of known and unknown variables of the LES and the constants, that are part of its coefficients. The data structure is used for various lookup operations. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a2c0e5fe28a9d36ad30d1555426db8b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function argument of <em>tbv_exportAsMCode:</em> The variables can be exported in different contexts of M code. Choose, which context to support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a2c0e5fe28a9d36ad30d1555426db8b59ab5c40e0f083a1771ab2f641d634a1357"></a>tbv_assignDefaultValues&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c0e5fe28a9d36ad30d1555426db8b59a9940e0d1019893710258924e2c4d9662"></a>tbv_assignParameterStruct&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a2c0e5fe28a9d36ad30d1555426db8b59af581c27993afaa229ecbff5eacd09462"></a>tbv_copyToParameterStruct&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac0c36afe5d520e1f4076c6ea4ddc7884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module prior to first use of any of its methods or global data objects.</p>
<p>Initialize the module at application startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="tbv__table_of_variables_8c.html#a3f5ca8f5ac35fa8320a60f72b81b7946">tbv_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab9ab3c84ad4e09d8ee596658669fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown of module after use. Release of memory, closing files, etc.</p>
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="a289cade8d2f18e3e4e9a01027fabe0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_createTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noKnowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noUnknowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pCircuitNetList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a table of variables, which is still empty.</p>
<p>Create a table of variables, which is still empty. Use the set of tbv_add functions to fill the table. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the new table is returned. Some memory has been allocated on the heap; therefore the object needs to be deleted again after usage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noKnowns</td><td>The number of knowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">noUnknowns</td><td>The number of unknowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">noConstants</td><td>The number of (physical) constants to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">pCircuitNetList</td><td>The elements of a table of variables refer to a parse result. Pass the pointer or reference to the related parse result object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>After creation the table will be filled using the different tbv_add functions. The table will then contain references into the parse result, another data structure. The client has to ensure that a copy (by reference) of this other data structure is held in this object. See tbv_setReferenceToNetList for more. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd>
<dd>
const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *tbv_setReferenceToNetList(<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> * const, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a5de1e84d24e0c14aa68e97d2fb5b4d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByShallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new object, which is a shallow copied of the passed one.</p>
<p>Copy a table of variables. It is a shallow copy, the immediate members are copied, in particular the arrays of knowns, unknowns and constants, but the associated net list object is copied only by reference. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to a new table is returned. Some memory has been allocated on the heap; therefore the object needs to be deleted again after usage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>The number of knowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation.object to copy is passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>

</div>
</div>
<a class="anchor" id="abf74786ef478ab7dbe6cde4a62fddc26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get another reference to the same object.</p>
<p>Request a reference to a table of variables. The new reference is counted internally for later and safe control of the delete operation.<br />
 Any requested reference needs to be freed with tbv_deleteTableOfVariables after use. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the passed pointer <em>pTabOfVars</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTabOfVars</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a6381ee040e21d959be597981e152160e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get another read-only reference to the same object.</p>
<p>Request a reference to a constant table of variables. The new reference is counted internally for later and safe control of the delete operation.<br />
 Any requested reference needs to be freed with tbv_deleteTableOfVariables after use. </p><dl class="section return"><dt>Returns</dt><dd>A read-only copy of the passed pointer <em>pTabOfVars</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTabOfVars</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br />
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="adcc7eff6ae0630047d542fcb7c579188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_deleteTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a table of variables or a reference to it after use.</p>
<p>Delete a reference to a table of variables after use. If there are no references left then the object itself is deleted, all memory is freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstTabOfVars</td><td>Pointer to the object to be deleted. No action if this is the NULL pointer.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_cloneByReference(<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Regardless of the destructive operation the object is declared read-only in order to support deletion of read-only copies of references to existing objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a23c7acab587bdb54bc76761b43edc856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_logTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the contents of a table of variables object to the application log.</p>
<p>Diagnostic function: Write the contents of a table of variables object to the application log. Logging is done on level DEBUG. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A reference to the table to be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86e47b2021631fb5761160ee8c830f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_addKnown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a known variable to the table.</p>
<p>Add a known variable to the table and assign a column of the LES, which holds the coefficients related to this known. </p><dl class="section return"><dt>Returns</dt><dd>Success. Failures can be ambiguous names, an overful table or an invalid column index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the table of variables, which the known is to be put into. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the known. Mainly used for reporting results. The string is copied into local memory of the table object. The passed pointer needs to be valid only during function execution. The name must not be NULL or the empty string. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>Knowns are related to devices (constant sources). A lookup function by device index is defined. To support the lookup function the index of the device is passed to this function. The index is related to the linear array of devices in the parse result (i.e. the circuit net list object). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. Errors caused by bad user input are reported to the application log. </dd></dl>

</div>
</div>
<a class="anchor" id="ab192c8d6735625c9771afdb7156cd621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_addUnknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idSubNet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an unknown variable to the table.</p>
<p>Add an unknown variable to the table and assign a column of the LES, that holds the coefficients related to this unknown. </p><dl class="section return"><dt>Returns</dt><dd>Success. Failures can be ambiguous names, an overful table or an invalid node or device index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the half-way completed table of variables, which the unknown is to be put into. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the unknown. Mainly used for reporting results. The string is copied into local memory of the table object. The passed pointer needs to be valid only during function execution. The name must not be NULL or the empty string. </td></tr>
    <tr><td class="paramname">idxNode</td><td>Most unknowns are voltages of nodes of the network. For these a lookup function by node is defined. To support the lookup function the index of the node is passed to this function. The index is related to the linear array of nodes in the parse result. Unknowns, that are not node voltages specify <a class="el" href="pci__parser_circuit_8h.html#a7f3fdcf0d9f687563edc266fe2457978">PCI_NULL_NODE</a>. </td></tr>
    <tr><td class="paramname">idSubNet</td><td>If idxNode is not <a class="el" href="pci__parser_circuit_8h.html#a7f3fdcf0d9f687563edc266fe2457978">PCI_NULL_NODE</a> then the ID of the sub-graph of the complete circuit is passed. All sub-graphs have a unique ID. The value UINT_MAX is reserved and must not be used as ID. Instead, pass UINT_MAX if the unknown is related to a device rather than to a node's voltage potential. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>Unknowns, which are not voltages of nodes of the network are related to devices (device currents mostly). For these a lookup function by device index is defined. To support the lookup function the index of the device is passed to this function. The index is related to the linear array of devices in the parse result. Unknowns, that are not device related specify <a class="el" href="pci__parser_circuit_8h.html#a998c4b91c0dd27119fded70db5220bbb">PCI_NULL_DEVICE</a>.<br />
 Either <em>idxNode</em> or <em>idxDevice</em> is specified but not both at a time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. Errors caused by bad user input are reported to the application log. </dd></dl>

</div>
</div>
<a class="anchor" id="a03935de59128a8b5b0950295b123b581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a constant to the table.</p>
<p>Add a physical device constant to the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the table of variables, which the constant is to be put into. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>A device's constant is closely related to the device. The table therefore holds the reference to a device object instead of a dedicated object to represent the constant.<br />
 The reference is implemented as the index of the device in the array of devices inside the parse result. (A read-only copy of the parse result is found inside the object * <em>pTable</em>.) The index refers to this table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d90b517ec9c3808eb5d6e02a208b0f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_sortConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort constants to get the common order R before L before C.</p>
<p>After having added all device constants with <em>tbv_addConstant</em> but prior to using the shaped association between a constant's name and its internal representation as a <em>coe_productOfConst_t</em> the very first time, the order of the constants in the table may be chosen. With other words: Which constant is associated with bit 0 of the internal representation, which one with bit 1, etc. The order gets apparent in all result output, where the constants with higher bit index are printed first. The most natural order of output of products of constants is R(esistor) before L (inductivity) before C(apacitor). This routine shapes an according order. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the object, whose constants are to be sorted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><em>tbv_addConstant</em> should not be called after calling this method; <em>tbv_getConstantByDevice</em>, <em>tbv_getDeviceByBitIndex</em> and <em>tbv_getReferencedDeviceByBitIndex</em> must not be called before calling this method; </dd></dl>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="tbv__table_of_variables_8c.html#a03935de59128a8b5b0950295b123b581">tbv_addConstant(tbv_tableOfVariables_t * const, unsigned int)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a82b3d754a0695ee117defd72a4db8921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_exportAsMCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const&#160;</td>
          <td class="paramname"><em>pMScript</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>indentStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the elements that are relevant to the executable Octave code into an M script.</p>
<p>Write the elements that are relevant to the executable Octave code into an M script. As a matter of fact, these are only the values of the device constants. To have executable code in any case the method writes default values to the M script where the input file doesn't specify actual values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the exported table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">pMScript</td><td>The pointer to an M script object. The generated M code is written into this M script. The object is the result of a successful call of boolean msc_createMScript(<a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> ** const, const char * const, const char * const, const char * const). </td></tr>
    <tr><td class="paramname">context</td><td>The variables can be exported in different contexts of M code. Choose, which context to support. </td></tr>
    <tr><td class="paramname">indentStr</td><td>The generated code starts with a new line. This and each other required line will begin with the passed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Find reasonable default values for controlled voltage sources. What are typical use cases? </dd></dl>

</div>
</div>
<a class="anchor" id="a26f1bac7852f707dc27fa1b9055d7c0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__known_variable__t.html">tbv_knownVariable_t</a>* tbv_getKnownByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the known, which represents a constant source.</p>
<p>Look for a known variable related to a device (a constant source) in the lookup table of knowns. </p><dl class="section return"><dt>Returns</dt><dd>The internal representation of the known is returned by reference. If <em>idxDevice</em> is not the index of a device, that defines an known voltage or current in the LES then an assertion fires. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device, the known is related to. The index refers to the array of devices in the parse result. PCI_NULL_DEVICE must not be passed as it is not a unique device identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a738e9acc910c1dee86990e7087ba7e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a>* tbv_getUnknownByNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the unknown, which represents a specific node's voltage.</p>
<p>Look for an unknown variable by node in the lookup table of those. </p><dl class="section return"><dt>Returns</dt><dd>The internal representation of the unknown is returned if <em>idxNode</em> represents one of the independent network nodes. If it designates a ground node then NULL is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxNode</td><td>The index of the node, the unknown is related to. The index refers to the array of nodes in the parse result. PCI_NULL_NODE must not be passed as it is not a unique node identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c7162b1123ba15a3eed6367c8733dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a>* tbv_getUnknownByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reference to the unknown, which represents the current through a specific devices.</p>
<p>Look for an unknown variable related to a device current in the lookup table of unknowns. </p><dl class="section return"><dt>Returns</dt><dd>The internal representation of the unknown is returned. If <em>idxDevice</em> is not the index of a device, that defines an unknown current in the LES then an assertion fires. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device, the unknown is related to. The index refers to the array of devices in the parse result. PCI_NULL_DEVICE must not be passed as it is not a unique device identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84fe5c8471002f477b82b2eada152b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coe__coefficient_8h.html#a53d35044911ab7bc1121b47d22e7e82c">coe_productOfConst_t</a> tbv_getConstantByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup of a device's constant by the index of the device.</p>
<p>Look for a constant in the lookup table of those. The constant is identified by the index of the device the constant belongs to. </p><dl class="section return"><dt>Returns</dt><dd>The internal representation of the constant is returned. It's a bit vector with a single set bit; this bit represents the constant. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The reference to the device to look for. A constant needs to be defined for this device (<em>tbv_addConstant</em>). The reference is implemented as the index of the device in the array of devices inside the parse result. (A read-only copy of the parse result is found inside the object * <em>pTable</em>.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a579d2f95cc4204f07dabe345b936d0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpci__device__t.html">pci_device_t</a>* tbv_getDeviceByBitIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup a device description by the it representing constant.</p>
<p>Look for a device description by the constant representing it. </p><dl class="section return"><dt>Returns</dt><dd>The pointer to the device descriptor is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxBit</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit is passed as key for the lookup operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a891cb33e9396da854317282fad2eb7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_getReferencedDeviceByBitIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrat__num__t.html">rat_num_t</a> *&#160;</td>
          <td class="paramname"><em>pRefFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__device__t.html">pci_device_t</a> **const&#160;</td>
          <td class="paramname"><em>ppDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pIdxBitRefDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for the decription of the device indirectly referenced by the constant representing a device.</p>
<p>Look for the description of the device indirectly referenced by the constant representing a device. Any device's value may be expressed as a product of a constant and the value of another device. This may happen recursively. If such a reference or chain of references is present for the device represented by the passed constant, than the last device in the chain of references is returned, together with the factor of the values. </p><dl class="section return"><dt>Returns</dt><dd>The other return values are valid only if the function returns true. If an error occurs a message is written to the global application and false is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">pRefFactor</td><td>The effective factor of the value of the device directly addressed by <em>idxBit</em> to the value of the finally referenced device ** <em>ppDevice</em>. </td></tr>
    <tr><td class="paramname">ppDevice</td><td>The pointer to the descriptor of the finally referenced device is placed in * <em>ppDevice</em>. In general, this is not the device addressed by <em>idxBit</em>. </td></tr>
    <tr><td class="paramname">pIdxBitRefDev</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit for the finally referenced device is placed in * <em>pIdxBitRefDev</em>. </td></tr>
    <tr><td class="paramname">idxBit</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit is passed as key for the look up operation of the first device in the chain of references. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1b7811ea00b8c3715e2b14d5ef5eacb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_setTargetUnknownForSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfUnknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select a specific unknown for result computation.</p>
<p>Select a specific unknown for result computation.<br />
 Currently, the solver is not capable to find a solution for all unknowns at once. It returns a fully eliminated solution only for the very unknown, whose coefficients are placed in the rightmost LHS column m of the LES. By simply exchanging two columns of the (later) LES on user demand, we can achieve that any unknown is represented in column m of the LES. Column swapping is what this method actually does. </p><dl class="section return"><dt>Returns</dt><dd>True if the desired unknown is known; then the operation succeeds. Otherwise false. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The assignment of unknowns to columns in the LES is specified in a table of variables. The pointer to such a table is passed. The table is modified in place. </td></tr>
    <tr><td class="paramname">nameOfUnknown</td><td>The unknown is selected by name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8298fcfb537a7f39dcc014d2590e4792.html">linNet</a></li><li class="navelem"><a class="el" href="tbv__table_of_variables_8h.html">tbv_tableOfVariables.h</a></li>
    <li class="footer">Generated on Tue Dec 30 2014 22:37:11 for linNet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
