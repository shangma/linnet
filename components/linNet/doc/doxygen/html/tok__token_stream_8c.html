<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>linNet: tok_tokenStream.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tok__token_stream_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tok_tokenStream.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;types.h&quot;</code><br/>
<code>#include &quot;smalloc.h&quot;</code><br/>
<code>#include &quot;snprintf.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="fio__fifo_char_8h_source.html">fio_fifoChar.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tok__token_stream_8h_source.html">tok_tokenStream.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a1e9f684844ecce1e50e6f2157fbb5b25">USE_LOCAL_BSEARCH</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3c7aea2dbec1de0ae89132ad755ee362">BSEARCH</a>&#160;&#160;&#160;bsearch</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a4e67e9429d48a2ba8f833ee3b1dceb5d">EOL</a>&#160;&#160;&#160;((signed int)'\n')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a8b9a3c26365e31993e9393ad1274b614">NUM_LITERAL_TO_STR</a>(num)&#160;&#160;&#160;INTERNAL_TO_STR(num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ab72fc37171e27764d40da7afb4944474">INTERNAL_TO_STR</a>(num)&#160;&#160;&#160;#num</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a31cd85fd426a62b06fe7c1a4e093f6cf">ERR_MSG_FSTR</a>&#160;&#160;&#160;&quot;Stream error in C stdio library, error number %d&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7a18f09d3bb5a5f03a55546e38f8efd8">ERR_MSG</a>&#160;&#160;&#160;&quot;End of file in string literal beginning on line %u&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a8c13e923567aefa55c9acb5b743f569f">MAX_LEN_NUMERAL</a>&#160;&#160;&#160;100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a254d24b8f1d393167bac4a6adb8b399b">INC_IDX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7a18f09d3bb5a5f03a55546e38f8efd8">ERR_MSG</a>&#160;&#160;&#160;&quot;End of file in comment beginning on line %u&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a37db7dd9eb6918b2df172765cb3ef2be">ERR_MSG_FMT_STR</a>&#160;&#160;&#160;&quot;Can't open input file %s (errno: %d, %s)&quot;</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="tok__token_stream_8c.html#a1fff2476924649765d90a17ecc9507ed">syntaxOptions_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a1fff2476924649765d90a17ecc9507ed">syntaxOptions_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a0fda7fa87f6d3f3c61f5d54f4afa044b">boolOption</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ae242f7ebe0360f20b15dac07165ee576">optionEscapeChar</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#aa6c7726c14a72f7c1048c0404d543f3f">optionStringQuote</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2f37979bbd27dcec7524afa770c1076f">isodigit</a> (signed int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#acfae0bf07f081b38d08a4cb5448ad9d4">iswhitespace</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, signed int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3605c123453ecc8207a154a852c26c3c">readCharFromStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a9df334147a2a0592e8c723a2bf4225ef">peekChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a929f7973517ba1f7451526a161e6532d">nextRawChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#afc83e19d32a62b4e289da5d923239a76">currentChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3b31f47c98820c739302e54a801fe307">readEscapedChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af315bc631cedacf4a366e4b3d7912b43">readStringLiteral</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af2e51c2a5ec8a56f773b37c3d3a147a7">readString</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a836f1e453a6496c5a30c076ff51be197">readNumeral</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ac2f36c5c8a8c369f4eeaf833c9f1f877">cmpTokenWithToken</a> (const void *p1, const void *p2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ae0fb956df17a0a03d2c132967768bc0b">cmpTokenWithKey</a> (const void *pKey, const void *pElem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2e836797c4eb01f33bac446a9fa1024f">readIdentifier</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7663828c42ee81da90dd53672e4ac9fb">readCharacterConstant</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#afbfa604448671e422faadb84a21173d9">readCustomSymbol</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a50acad930e5c64ed791a86e0dfea2be3">readComment</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a4669f501bd99188c558711c333b64964">createTokenDescriptorTable</a> (<a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const pTokenStream, const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const pCustomTokenDefinition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a47c0afab55aa777b30bc9ed2dec78895">deleteTokenDescriptorTable</a> (<a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const pTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#abff0f873238e261cf7f90cff1d02c037">tok_createTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const phTokenStream, char **const pErrorString, const char *const fileName, <a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a> hStream, const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a> customFctGetChar, const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const pCustomTokenDefinition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af885a6c23c60d867f2b1848287b422aa">tok_deleteTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#aaa9a0a9c8c50295303866a2ac6752fdb">tok_setBoolOption</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> option, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a5ebbbd6e89026ec97adecd5e2ca296c2">tok_getErrorMsg</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, const char **const pErrMsg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#abf05149020c59eac572e33b614034a1d">tok_getLine</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2d0f70b3c401fedd8730c15699392db1">tok_fprintfToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, FILE *hStream, const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This module implements a token scanner for lexical symbols as used in the language C and many other languages. The input is parsed and returned to the client as a sequence of tokens.<br/>
 The syntax definitions is somewhat open to configuration. Particular single characters or sequences of such can be defined to become named tokens. This way application dependent keywords and operators can be defined. Some syntax elements are hard coded and can't be re-defined, examples are number literals or identifiers.<br/>
 The hard coded built-in syntax elements have priority over the client configured tokens. This means the latter cannot begin with a sequence of characters that resembles a built-in element, followed by some other characters, which would make them basically distinguishable: For example abc++cba is not supported as a user configured symbol. The scanner would first recognize an identifier abc and then fail to recognize the rest. Same for 'q, "xx or 23a, which are conflicting with character constants (beginning with
 '), string literals (beginning with ") and numerals (beginning with a digit). ++abc would however be a valid custom symbol.<br/>
 Binary literals are an option (1001) and suffix multipliers are an option (3.45k) but for floating point numerals only.<br/>
 String constants can be enclosed in single or double quotes. However, if single quotes are configured, then no C like character constants are recognized - they would be returned as strings of length one.<br/>
 The end of line character can be handled as (ignored) white space or as recognized and returned token.<br/>
 Comments can be enclosed in a pair of tags or they have a starting tag and end in front of the next end of line character. All three needed tags can be configured.<br/>
 As long as no syntax error is found the scanner always returns a token. If it cannot match an input character to any of the more complex token types it'll return the character itself as token, i.e. the token type is set to the character code. This design decision has been taken because most parsers have to handle a lot of single character tokens like parenthesis and these are implicitly defined.</p>
<p>Copyright (C) 1992-2014 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1e9f684844ecce1e50e6f2157fbb5b25"></a><!-- doxytag: member="tok_tokenStream.c::USE_LOCAL_BSEARCH" ref="a1e9f684844ecce1e50e6f2157fbb5b25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USE_LOCAL_BSEARCH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some compiler environments do not know the binary search routine. Then define the next symbol to be 1 and compile a local implementation. </p>

</div>
</div>
<a class="anchor" id="a3c7aea2dbec1de0ae89132ad755ee362"></a><!-- doxytag: member="tok_tokenStream.c::BSEARCH" ref="a3c7aea2dbec1de0ae89132ad755ee362" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSEARCH&#160;&#160;&#160;bsearch</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e67e9429d48a2ba8f833ee3b1dceb5d"></a><!-- doxytag: member="tok_tokenStream.c::EOL" ref="a4e67e9429d48a2ba8f833ee3b1dceb5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EOL&#160;&#160;&#160;((signed int)'\n')</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The end of line indicator. </p>

</div>
</div>
<a class="anchor" id="a8b9a3c26365e31993e9393ad1274b614"></a><!-- doxytag: member="tok_tokenStream.c::NUM_LITERAL_TO_STR" ref="a8b9a3c26365e31993e9393ad1274b614" args="(num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_LITERAL_TO_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num</td><td>)</td>
          <td>&#160;&#160;&#160;INTERNAL_TO_STR(num)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use a constant number as string literal, e.g. for static, compile time status messages. </p>

</div>
</div>
<a class="anchor" id="ab72fc37171e27764d40da7afb4944474"></a><!-- doxytag: member="tok_tokenStream.c::INTERNAL_TO_STR" ref="ab72fc37171e27764d40da7afb4944474" args="(num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERNAL_TO_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num</td><td>)</td>
          <td>&#160;&#160;&#160;#num</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a31cd85fd426a62b06fe7c1a4e093f6cf"></a><!-- doxytag: member="tok_tokenStream.c::ERR_MSG_FSTR" ref="a31cd85fd426a62b06fe7c1a4e093f6cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG_FSTR&#160;&#160;&#160;&quot;Stream error in C stdio library, error number %d&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a18f09d3bb5a5f03a55546e38f8efd8"></a><!-- doxytag: member="tok_tokenStream.c::ERR_MSG" ref="a7a18f09d3bb5a5f03a55546e38f8efd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG&#160;&#160;&#160;&quot;End of file in string literal beginning on line %u&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c13e923567aefa55c9acb5b743f569f"></a><!-- doxytag: member="tok_tokenStream.c::MAX_LEN_NUMERAL" ref="a8c13e923567aefa55c9acb5b743f569f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_LEN_NUMERAL&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a254d24b8f1d393167bac4a6adb8b399b"></a><!-- doxytag: member="tok_tokenStream.c::INC_IDX" ref="a254d24b8f1d393167bac4a6adb8b399b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INC_IDX</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{   <span class="keywordflow">if</span>(idx &lt; MAX_LEN_NUMERAL)                                                       \
                ++ idx;                                                                     \
            <span class="keywordflow">else</span>                                                                            \
            {                                                                               \
                hTStream-&gt;error = <span class="keyword">true</span>;                                                     \
                free((<span class="keywordtype">char</span>*)hTStream-&gt;errorMsg);                                            \
                hTStream-&gt;errorMsg = <a class="code" href="smalloc_8h.html#a549bfea173bfee7c36649d552559d826">stralloccpy</a>(<span class="stringliteral">&quot;Numeral is too long. Only up to &quot;</span>         \
                                                 <a class="code" href="tok__token_stream_8c.html#a8b9a3c26365e31993e9393ad1274b614">NUM_LITERAL_TO_STR</a>(MAX_LEN_NUMERAL)        \
                                                 <span class="stringliteral">&quot; characters are allowed&quot;</span>                  \
                                                );                                          \
            }                                                                               \
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a7a18f09d3bb5a5f03a55546e38f8efd8"></a><!-- doxytag: member="tok_tokenStream.c::ERR_MSG" ref="a7a18f09d3bb5a5f03a55546e38f8efd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG&#160;&#160;&#160;&quot;End of file in comment beginning on line %u&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a37db7dd9eb6918b2df172765cb3ef2be"></a><!-- doxytag: member="tok_tokenStream.c::ERR_MSG_FMT_STR" ref="a37db7dd9eb6918b2df172765cb3ef2be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG_FMT_STR&#160;&#160;&#160;&quot;Can't open input file %s (errno: %d, %s)&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a1fff2476924649765d90a17ecc9507ed"></a><!-- doxytag: member="tok_tokenStream.c::syntaxOptions_t" ref="a1fff2476924649765d90a17ecc9507ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="tok__token_stream_8c.html#a1fff2476924649765d90a17ecc9507ed">syntaxOptions_t</a>  <a class="el" href="tok__token_stream_8c.html#a1fff2476924649765d90a17ecc9507ed">syntaxOptions_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Some syntax construct of the tokenizer are optional, i.e. they can be switched on or off in order to customize the behavior. </p>

</div>
</div>
<a class="anchor" id="a492db6d845865f86df79ccc633dacf78"></a><!-- doxytag: member="tok_tokenStream.c::tok_tokenStream_t" ref="a492db6d845865f86df79ccc633dacf78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a>  <a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The token stream. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0fda7fa87f6d3f3c61f5d54f4afa044b"></a><!-- doxytag: member="tok_tokenStream.c::boolOption" ref="a0fda7fa87f6d3f3c61f5d54f4afa044b" args="(const tok_hTokenStream_t hTStream, tok_syntaxOption_t option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> boolOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a>&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a boolean option of the tokenizer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True or flase, the current setting of the option. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
    <tr><td class="paramname">option</td><td>Pass in, which Boolean option to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae242f7ebe0360f20b15dac07165ee576"></a><!-- doxytag: member="tok_tokenStream.c::optionEscapeChar" ref="ae242f7ebe0360f20b15dac07165ee576" args="(const tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int optionEscapeChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query option tok_optionEscapeCharIsDollarSign of the tokenizer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the selected escape character for character constants. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6c7726c14a72f7c1048c0404d543f3f"></a><!-- doxytag: member="tok_tokenStream.c::optionStringQuote" ref="aa6c7726c14a72f7c1048c0404d543f3f" args="(const tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int optionStringQuote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query option tok_optionStringsUseSingleQuotes of the tokenizer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the selected quote character for string literals. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f37979bbd27dcec7524afa770c1076f"></a><!-- doxytag: member="tok_tokenStream.c::isodigit" ref="a2f37979bbd27dcec7524afa770c1076f" args="(signed int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isodigit </td>
          <td>(</td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decide, whether a character is an octal digit (0..7). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the Boolean answer. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfae0bf07f081b38d08a4cb5448ad9d4"></a><!-- doxytag: member="tok_tokenStream.c::iswhitespace" ref="acfae0bf07f081b38d08a4cb5448ad9d4" args="(tok_hTokenStream_t hTStream, signed int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> iswhitespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decide, whether a character is white space. This function replaces the function isspace from the standard library because it treats the end of line differently: This is a token of particular interest by default. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the Boolean answer. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which is needed to access the option whether EOL is white space or not. </td></tr>
    <tr><td class="paramname">c</td><td>The character to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3605c123453ecc8207a154a852c26c3c"></a><!-- doxytag: member="tok_tokenStream.c::readCharFromStream" ref="a3605c123453ecc8207a154a852c26c3c" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int readCharFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the next character from the actual stream, be it a stdio stream or an externally implemented custom stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9df334147a2a0592e8c723a2bf4225ef"></a><!-- doxytag: member="tok_tokenStream.c::peekChar" ref="a9df334147a2a0592e8c723a2bf4225ef" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int peekChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Look at the next character in the stream. This is the character, the next call of signed int <a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar(tok_hTokenStream_t hTokenStream)</a> will return.<br/>
 The call of this function does not iterate versus the future stream characters. If it is called repeatedly it'll always return the same character, which is the next one until nextChar is called. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the preview on the next character in the stream. The character is however not consumed from the stream. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929f7973517ba1f7451526a161e6532d"></a><!-- doxytag: member="tok_tokenStream.c::nextRawChar" ref="a929f7973517ba1f7451526a161e6532d" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int nextRawChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next character from the input stream. Normally the other function nextChar will be used by the scanner. This function is a bit more low level: It doesn't consider a line concatenation by the pair backslash+NL, but will return both characters as such in subsequent calls. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a998d5260ee975383a18be95b1a99d420"></a><!-- doxytag: member="tok_tokenStream.c::nextChar" ref="a998d5260ee975383a18be95b1a99d420" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int nextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next character from the input stream. Line concatenation by backslash+EOL is handled by the function, so it's transparent to the caller (besides an increment of the line number counter). Which means that a comment of type till-end-of-line can also benefit from line concatenation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc83e19d32a62b4e289da5d923239a76"></a><!-- doxytag: member="tok_tokenStream.c::currentChar" ref="afc83e19d32a62b4e289da5d923239a76" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int currentChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the last recently read input character once again. The stream is not accessed at all. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the same character as got in the preceding call of int <a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar(tok_hTokenStream_t)</a> or EOF if the other function had not been called yet. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b31f47c98820c739302e54a801fe307"></a><!-- doxytag: member="tok_tokenStream.c::readEscapedChar" ref="a3b31f47c98820c739302e54a801fe307" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int readEscapedChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the value of a character, that is defined by an expression starting with the backslash. The backslash was already consumed from the input stream by the calling function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the character is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af315bc631cedacf4a366e4b3d7912b43"></a><!-- doxytag: member="tok_tokenStream.c::readStringLiteral" ref="af315bc631cedacf4a366e4b3d7912b43" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* readStringLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the contents of a string literal. This is everything in between a pair of (not escaped) quotes. The closing quote is not consumed from the input stream. Escape characters inside the string contents are resolved and no longer visible to the caller. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string contents are returned as malloc allocated string. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>static char *readString(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="af2e51c2a5ec8a56f773b37c3d3a147a7"></a><!-- doxytag: member="tok_tokenStream.c::readString" ref="af2e51c2a5ec8a56f773b37c3d3a147a7" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a complete string constant. As in C, this is the concatenation of (double) quote enclosed string literals, if they are separated by white space only.<br/>
 Attention: It is an option to see the EOL character not as white space but as a token. In this case string literal concatenation becomes rather useless as it is used in practice to break a lengthy string into different lines of source code. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The string complete contents are returned as malloc allocated string. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read string token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>static char *readStringLiteral(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a836f1e453a6496c5a30c076ff51be197"></a><!-- doxytag: member="tok_tokenStream.c::readNumeral" ref="a836f1e453a6496c5a30c076ff51be197" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readNumeral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the characters from the input stream that belong to and form a numeral. Binary, octal, decimal and hexadecimal literals are supported and floating point numbers.<br/>
 Only positive numbers are considered. A possible sign would be a different, preceding token, to be handled by the client parser. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read number token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2f36c5c8a8c369f4eeaf833c9f1f877"></a><!-- doxytag: member="tok_tokenStream.c::cmpTokenWithToken" ref="ac2f36c5c8a8c369f4eeaf833c9f1f877" args="(const void *p1, const void *p2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int cmpTokenWithToken </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comparsion of two tokens in the token description table: Needed to sort the table initially. See qsort for more. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0: The element pointed by <em>p1</em> goes before the element pointed by <em>p2</em>.<br/>
 0: The element pointed by <em>p1</em> is equivalent to the element pointed by <em>p2</em>.<br/>
 &gt;0: The element pointed by <em>p1</em> goes after the element pointed by <em>p2</em>.<br/>
 </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Points to the first token description. </td></tr>
    <tr><td class="paramname">p2</td><td>Points to the second token description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function is solely used by bsearch to look for a found identifier in the given table of known keywords. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fb956df17a0a03d2c132967768bc0b"></a><!-- doxytag: member="tok_tokenStream.c::cmpTokenWithKey" ref="ae0fb956df17a0a03d2c132967768bc0b" args="(const void *pKey, const void *pElem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static signed int cmpTokenWithKey </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Comparsion of a token in the token description table with a key. The key is the symbol (a string) represented by the token. The comparison is needed to do a binary search for a given token in the table of client defined symbols. See bsearch for more. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0: The element pointed by <em>pKey</em> goes before the element pointed by <em>pElem</em>.<br/>
 0: The element pointed by <em>pKey</em> is equivalent to the element pointed by <em>pElem</em>.<br/>
 &gt;0: The element pointed by <em>pKey</em> goes after the element pointed by <em>pElem</em>.<br/>
 </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pKey</td><td>Points to the key to match with <em>pElem</em>. * <em>pElem</em> will probably have a field, which is matched with the key value. </td></tr>
    <tr><td class="paramname">pElem</td><td>The element to be compared with the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function is solely used by bsearch to look for a found identifier in the given table of known keywords. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e836797c4eb01f33bac446a9fa1024f"></a><!-- doxytag: member="tok_tokenStream.c::readIdentifier" ref="a2e836797c4eb01f33bac446a9fa1024f" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the characters from the input stream that belong to and form an identifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7663828c42ee81da90dd53672e4ac9fb"></a><!-- doxytag: member="tok_tokenStream.c::readCharacterConstant" ref="a7663828c42ee81da90dd53672e4ac9fb" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readCharacterConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the characters from the input stream that belong to and form a character constant as defined in C. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbfa604448671e422faadb84a21173d9"></a><!-- doxytag: member="tok_tokenStream.c::readCustomSymbol" ref="afbfa604448671e422faadb84a21173d9" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readCustomSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The current input character can't immediately be related to a lexical standard atom so try to match this and the subsequent input characters to a custom symbol. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50acad930e5c64ed791a86e0dfea2be3"></a><!-- doxytag: member="tok_tokenStream.c::readComment" ref="a50acad930e5c64ed791a86e0dfea2be3" args="(tok_hTokenStream_t hTStream, const tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void readComment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The beginning of a comment had been recognized. This routine reads the comment contents until and including the comment end tag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br/>
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>On entry, the token contains the just recognized comment starting token. This function does not change the token as the comment's contents are simply skipped and not returned to the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4669f501bd99188c558711c333b64964"></a><!-- doxytag: member="tok_tokenStream.c::createTokenDescriptorTable" ref="a4669f501bd99188c558711c333b64964" args="(tok_tokenStream_t *const pTokenStream, const tok_tokenDescriptorTable_t *const pCustomTokenDefinition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void createTokenDescriptorTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>pTokenStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const&#160;</td>
          <td class="paramname"><em>pCustomTokenDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the token descriptor table in a newly created token stream object by making a deep copy of the client specified token definition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pTokenStream</td><td>The handle of the token stream object. The operation is part of the creation of such an object. When calling this function, the object will be incomplete. Only the token definition related parts will be accessed. </td></tr>
    <tr><td class="paramname">pCustomTokenDefinition</td><td>The user provided specification of custom symbols and their token values by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47c0afab55aa777b30bc9ed2dec78895"></a><!-- doxytag: member="tok_tokenStream.c::deleteTokenDescriptorTable" ref="a47c0afab55aa777b30bc9ed2dec78895" args="(tok_tokenStream_t *const pTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void deleteTokenDescriptorTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>pTokenStream</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Counterpart to createTokenDescriptorTable: The token descritor table is deleted, all malloc allocated strings are freed. The function is used from inside the destructor of a token stream object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pTokenStream</td><td>The pointer to the currently deleted token stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abff0f873238e261cf7f90cff1d02c037"></a><!-- doxytag: member="tok_tokenStream.c::tok_createTokenStream" ref="abff0f873238e261cf7f90cff1d02c037" args="(tok_hTokenStream_t *const phTokenStream, char **const pErrorString, const char *const fileName, tok_hStream_t hStream, const tok_customFctGetChar customFctGetChar, const tok_tokenDescriptorTable_t *const pCustomTokenDefinition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_createTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>phTokenStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **const&#160;</td>
          <td class="paramname"><em>pErrorString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a>&#160;</td>
          <td class="paramname"><em>customFctGetChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const&#160;</td>
          <td class="paramname"><em>pCustomTokenDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A token stream object is created. It is associated with either a stdio stream or with any kind of custom character stream. The created object can be used to parse the input from that stream into a sequence of lexcical atoms or tokens. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True, if the stream could be opened successfully, or false otherwise. The only other operation, which is permitted to be applied to the returned object, is tok_deleteTokenStream if the function returns false. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">phTokenStream</td><td>The handle to the created object is placed into <em>phTokenStream</em>. </td></tr>
    <tr><td class="paramname">pErrorString</td><td>A pointer to a string variable owned by the caller. If an error appears, then a malloc allocated read-only string is placed into this variable. Normally NULL is returned in * <em>pErrorString</em>.<br/>
 Caution: The caller is in charge to free the string after use. </td></tr>
    <tr><td class="paramname">fileName</td><td>The name of the file (or character stream), which is parsed. Mainly used for logging. Only, if hFile is NULL then it really needs to be the name of (and path to) an existing file. This file will then be opened for read access and be parsed.<br/>
 If there's no reasonable name (e.g. in case of custom character input) then pass NULL or the empty string. </td></tr>
    <tr><td class="paramname">hStream</td><td>The parsed stream object. Either a stream from the stdio library or a custom stream of unknown type.<br/>
 If parameter <em>customGetChar</em> is not NULL, then <em>hStream</em> is interpreted as handle of the custom stream. Otherwise it is interpreted as stdio stream (FILE*). In the latter case NULL may be passed: A file <em>fileName</em> will be opened as stdio stream and will be parsed then. </td></tr>
    <tr><td class="paramname">customFctGetChar</td><td>The pointer to a custom character input function, which reads a single character from a custom stream of type tok_hCharInputStream_t. Pass NULL if the stdio input should be used. </td></tr>
    <tr><td class="paramname">pCustomTokenDefinition</td><td>The customer provided extension of the internal symbol definitions. Basically a table associating symbols with token values. The tokenizer will look for the symbols in the input stream and return the associated token value if finds one. Additionally the symbols are specified, which mark beginning and end of comments.<br/>
 Pass NULL if no custom symbols are needed.<br/>
 The constructor makes a deep copy of the passed objects. All contained strings can be deleted after return from the constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af885a6c23c60d867f2b1848287b422aa"></a><!-- doxytag: member="tok_tokenStream.c::tok_deleteTokenStream" ref="af885a6c23c60d867f2b1848287b422aa" args="(tok_hTokenStream_t hTokenStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_deleteTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a token stream object as created by tok_createTokenStream. A possibly open stdio stream is closed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The handle to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa9a0a9c8c50295303866a2ac6752fdb"></a><!-- doxytag: member="tok_tokenStream.c::tok_setBoolOption" ref="aaa9a0a9c8c50295303866a2ac6752fdb" args="(tok_hTokenStream_t hTStream, tok_syntaxOption_t option, boolean value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_setBoolOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set an option of the tokenizer. Do this after object creation but prior to the first invocation of boolean <a class="el" href="tok__token_stream_8h.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken(tok_hTokenStream_t, tok_token_t * const)</a>.<br/>
 See enumeration <em>tok_syntaxOption_t</em> for the available options. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">option</td><td>The selected option. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ebbbd6e89026ec97adecd5e2ca296c2"></a><!-- doxytag: member="tok_tokenStream.c::tok_getErrorMsg" ref="a5ebbbd6e89026ec97adecd5e2ca296c2" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tok_getErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current, last recently set error message. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get a read-only string. The returned pointer is only valid until the next invocation of any method on the token stream object. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="tok__token_stream_8h.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError(tok_hTokenStream_t, const char ** const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16729b7f12f3a293663c6039b6d3979a"></a><!-- doxytag: member="tok_tokenStream.c::tok_resetError" ref="a16729b7f12f3a293663c6039b6d3979a" args="(tok_hTokenStream_t hTStream, const char **const pErrMsg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_resetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>pErrMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acknwledge an error. Most often, a parser will try to continue the process even after an error. If it reported an error from the tokenizer, it should explicitly reset the error in the token stream prior to calling tok_getNextToken the next time. Otherwise it looses the chance to see new errors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The cleared error status is returned. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">pErrMsg</td><td>If not NULL the current (now cleared) error message is placed into * <em>pErrMsg</em>. The returned value is the pointer to a temporary read only string. It is valid only until the next call of whatever method of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>const char *tok_getErrorMsg(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="abf05149020c59eac572e33b614034a1d"></a><!-- doxytag: member="tok_tokenStream.c::tok_getLine" ref="abf05149020c59eac572e33b614034a1d" args="(tok_hTokenStream_t hTStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tok_getLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current line number of the input stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the line number. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d0f70b3c401fedd8730c15699392db1"></a><!-- doxytag: member="tok_tokenStream.c::tok_fprintfToken" ref="a2d0f70b3c401fedd8730c15699392db1" args="(tok_hTokenStream_t hTStream, FILE *hStream, const tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_fprintfToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Debug function (compiled only on demand, see <a class="el" href="tok__token_stream_8h.html#a45b048360c789ee610a202540443e606">TOK_COMPILE_FPRINTF_TOKEN</a>):<br/>
 The type and value of a token is printed into a stdio stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">hStream</td><td>A handle to a stdio file with write access in text mode. </td></tr>
    <tr><td class="paramname">pToken</td><td>The token is passed in by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6265f294842ee4d9e2c4fa2909e47a8f"></a><!-- doxytag: member="tok_tokenStream.c::tok_getNextToken" ref="a6265f294842ee4d9e2c4fa2909e47a8f" args="(tok_hTokenStream_t hTStream, tok_token_t *const pToken)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_getNextToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Main operation on a token stream: Read the next token (or lexical atom) from the input stream.<br/>
 The end-of-file is always defined as a token. The client of this class will call this method in a loop until it gets the token EOF. Further calls are permitted but will always return EOF again. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Recognizing tokens in read character sequences can fail. If the next characters in the stream do not form any defined token, then the function returns false. The client knows that there is a syntax error. It can request the error message by const char *tok_getErrorMsg(tok_hTokenStream_t). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object to read from. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tok__token_stream_8c.html">tok_tokenStream.c</a>      </li>
      <li class="footer">Generated on Wed Dec 10 2014 21:31:12 for linNet by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
