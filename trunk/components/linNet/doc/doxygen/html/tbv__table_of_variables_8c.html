<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>linNet: tbv_tableOfVariables.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8298fcfb537a7f39dcc014d2590e4792.html">linNet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tbv_tableOfVariables.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="smalloc_8h_source.html">smalloc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="stricmp_8h_source.html">stricmp.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log__logger_8h_source.html">log_logger.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qsort__c_8h_source.html">qsort_c.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rat__rational_number_8h_source.html">rat_rationalNumber.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pci__parser_circuit_8h_source.html">pci_parserCircuit.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="msc__m_script_8h_source.html">msc_mScript.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="tbv__table_of_variables_8h_source.html">tbv_tableOfVariables.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa2fabf4f6af89f61ba9494a05049922e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#aa2fabf4f6af89f61ba9494a05049922e">F64X</a>&#160;&#160;&#160;&quot;%llx&quot;</td></tr>
<tr class="separator:aa2fabf4f6af89f61ba9494a05049922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7ed5c78e6777a81a58db9b75e0491bc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a7ed5c78e6777a81a58db9b75e0491bc8">checkName</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const nameToCheck, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isKnown)</td></tr>
<tr class="separator:a7ed5c78e6777a81a58db9b75e0491bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c23a27318f3f0d21708640b5fabb4"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a6b5c23a27318f3f0d21708640b5fabb4">cmpDeviceConstantNames</a> (const void *pIdxDev1, const void *pIdxDev2, const void *pContext)</td></tr>
<tr class="separator:a6b5c23a27318f3f0d21708640b5fabb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af548fc88bbdbc101dc6a2f95672d9e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#af548fc88bbdbc101dc6a2f95672d9e56">tbv_initModule</a> (<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hLogger)</td></tr>
<tr class="separator:af548fc88bbdbc101dc6a2f95672d9e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5ca8f5ac35fa8320a60f72b81b7946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a3f5ca8f5ac35fa8320a60f72b81b7946">tbv_shutdownModule</a> ()</td></tr>
<tr class="separator:a3f5ca8f5ac35fa8320a60f72b81b7946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289cade8d2f18e3e4e9a01027fabe0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a289cade8d2f18e3e4e9a01027fabe0b7">tbv_createTableOfVariables</a> (unsigned int noKnowns, unsigned int noUnknowns, unsigned int noConstants, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const pCircuitNetList)</td></tr>
<tr class="separator:a289cade8d2f18e3e4e9a01027fabe0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1e84d24e0c14aa68e97d2fb5b4d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a5de1e84d24e0c14aa68e97d2fb5b4d6c">tbv_cloneByShallowCopy</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a5de1e84d24e0c14aa68e97d2fb5b4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74786ef478ab7dbe6cde4a62fddc26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#abf74786ef478ab7dbe6cde4a62fddc26">tbv_cloneByReference</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTabOfVars)</td></tr>
<tr class="separator:abf74786ef478ab7dbe6cde4a62fddc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6381ee040e21d959be597981e152160e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a6381ee040e21d959be597981e152160e">tbv_cloneByConstReference</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTabOfVars)</td></tr>
<tr class="separator:a6381ee040e21d959be597981e152160e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aefd54a051bcc2910a962da903372d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a54aefd54a051bcc2910a962da903372d">tbv_deleteTableOfVariables</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pConstTabOfVars)</td></tr>
<tr class="separator:a54aefd54a051bcc2910a962da903372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c7acab587bdb54bc76761b43edc856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a23c7acab587bdb54bc76761b43edc856">tbv_logTableOfVariables</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable)</td></tr>
<tr class="separator:a23c7acab587bdb54bc76761b43edc856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e47b2021631fb5761160ee8c830f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a86e47b2021631fb5761160ee8c830f51">tbv_addKnown</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const name, unsigned int idxDevice)</td></tr>
<tr class="separator:a86e47b2021631fb5761160ee8c830f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a404154eaab98112f030a33e75b6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a61a404154eaab98112f030a33e75b6b3">tbv_addUnknown</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const name, unsigned int idxNode, unsigned int idSubNet, unsigned int idxDevice)</td></tr>
<tr class="separator:a61a404154eaab98112f030a33e75b6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03935de59128a8b5b0950295b123b581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a03935de59128a8b5b0950295b123b581">tbv_addConstant</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a03935de59128a8b5b0950295b123b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d90b517ec9c3808eb5d6e02a208b0f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a6d90b517ec9c3808eb5d6e02a208b0f2">tbv_sortConstants</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable)</td></tr>
<tr class="separator:a6d90b517ec9c3808eb5d6e02a208b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b3d754a0695ee117defd72a4db8921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a82b3d754a0695ee117defd72a4db8921">tbv_exportAsMCode</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, <a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const pMScript, <a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a> context, const char *const indentStr)</td></tr>
<tr class="separator:a82b3d754a0695ee117defd72a4db8921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f1bac7852f707dc27fa1b9055d7c0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__known_variable__t.html">tbv_knownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a26f1bac7852f707dc27fa1b9055d7c0a">tbv_getKnownByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a26f1bac7852f707dc27fa1b9055d7c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738e9acc910c1dee86990e7087ba7e53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a738e9acc910c1dee86990e7087ba7e53">tbv_getUnknownByNode</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxNode)</td></tr>
<tr class="separator:a738e9acc910c1dee86990e7087ba7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7162b1123ba15a3eed6367c8733dc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a7c7162b1123ba15a3eed6367c8733dc8">tbv_getUnknownByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a7c7162b1123ba15a3eed6367c8733dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe5c8471002f477b82b2eada152b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="coe__coefficient_8h.html#a53d35044911ab7bc1121b47d22e7e82c">coe_productOfConst_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a84fe5c8471002f477b82b2eada152b34">tbv_getConstantByDevice</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxDevice)</td></tr>
<tr class="separator:a84fe5c8471002f477b82b2eada152b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d2f95cc4204f07dabe345b936d0d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpci__device__t.html">pci_device_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a579d2f95cc4204f07dabe345b936d0d4">tbv_getDeviceByBitIndex</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, unsigned int idxBit)</td></tr>
<tr class="separator:a579d2f95cc4204f07dabe345b936d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891cb33e9396da854317282fad2eb7f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a891cb33e9396da854317282fad2eb7f7">tbv_getReferencedDeviceByBitIndex</a> (const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, <a class="el" href="structrat__num__t.html">rat_num_t</a> *pRefFactor, const <a class="el" href="structpci__device__t.html">pci_device_t</a> **const ppDevice, unsigned int *pIdxBitRefDev, unsigned int idxBit)</td></tr>
<tr class="separator:a891cb33e9396da854317282fad2eb7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7811ea00b8c3715e2b14d5ef5eacb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#af1b7811ea00b8c3715e2b14d5ef5eacb">tbv_setTargetUnknownForSolver</a> (<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTable, const char *const nameOfUnknown)</td></tr>
<tr class="separator:af1b7811ea00b8c3715e2b14d5ef5eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a470f8d09d6a16be38c7ac76067642fc3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a470f8d09d6a16be38c7ac76067642fc3">_log</a> = <a class="el" href="log__logger_8h.html#aef9403182a4900c1b62a11082dd7bdb6">LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</a></td></tr>
<tr class="separator:a470f8d09d6a16be38c7ac76067642fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470a463163890645f09c7b90f2e1de48"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tbv__table_of_variables_8c.html#a470a463163890645f09c7b90f2e1de48">_noRefsToObjects</a> = 0</td></tr>
<tr class="separator:a470a463163890645f09c7b90f2e1de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module implements a data structure that holds all symbolic elements of the LES and the solution: The known and unknown variables and the (physical) constants. The table lists these elements together with some of its properties. Access functions are provided that permit to look for a symbolic element by a property.</p>
<p>Copyright (C) 2013-2014 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aa2fabf4f6af89f61ba9494a05049922e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define F64X&#160;&#160;&#160;&quot;%llx&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7ed5c78e6777a81a58db9b75e0491bc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> checkName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameToCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>isKnown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double-check that the name of a known or unknown is not yet in use for another known, unknown or constant. Report a problem in the application log. </p>
<dl class="section return"><dt>Returns</dt><dd>True if passed name is still unused. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the table of variables. The object under test has not yet been entered at all. </td></tr>
    <tr><td class="paramname">nameToCheck</td><td>The name to validate. It must not be NULL or the empty string. </td></tr>
    <tr><td class="paramname">isKnown</td><td>Pass <em>true</em> if the name of a known quantity is checked and <em>false</em> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b5c23a27318f3f0d21708640b5fabb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int cmpDeviceConstantNames </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pIdxDev1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pIdxDev2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare function for qsort; used to sort the device constants so that the result presents them in the order R, L, C. Used by <em>tbv_sortConstants</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if second operand comes prior to the first operand in the aimed sort order<br/>
 =0 if if order of bothe opearnds doesn't care in the aimed sort order (they are identical with respect to the sort criteria)<br/>
 &lt;1 if second operand comes after the first operand in the aimed sort order </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pIdxDev1</td><td>Pointer into the sorted array; points to first comparsion operand. </td></tr>
    <tr><td class="paramname">pIdxDev2</td><td>Pointer into the sorted array; points to second comparsion operand. </td></tr>
    <tr><td class="paramname">pContext</td><td>Context pointer, which is passed unchanged to all invokations of this routine. Here it points to the table of variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af548fc88bbdbc101dc6a2f95672d9e56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module at application startup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="tbv__table_of_variables_8c.html#a3f5ca8f5ac35fa8320a60f72b81b7946">tbv_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f5ca8f5ac35fa8320a60f72b81b7946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="a289cade8d2f18e3e4e9a01027fabe0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_createTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noKnowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noUnknowns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *const&#160;</td>
          <td class="paramname"><em>pCircuitNetList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a table of variables, which is still empty. Use the set of tbv_add functions to fill the table. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new table is returned. Some memory has been allocated on the heap; therefore the object needs to be deleted again after usage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noKnowns</td><td>The number of knowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">noUnknowns</td><td>The number of unknowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">noConstants</td><td>The number of (physical) constants to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation. </td></tr>
    <tr><td class="paramname">pCircuitNetList</td><td>The elements of a table of variables refer to a parse result. Pass the pointer or reference to the related parse result object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>After creation the table will be filled using the different tbv_add functions. The table will then contain references into the parse result, another data structure. The client has to ensure that a copy (by reference) of this other data structure is held in this object. See tbv_setReferenceToNetList for more. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd>
<dd>
const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> *tbv_setReferenceToNetList(<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> * const, const <a class="el" href="structpci__circuit__t.html">pci_circuit_t</a> * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a5de1e84d24e0c14aa68e97d2fb5b4d6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByShallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a table of variables. It is a shallow copy, the immediate members are copied, in particular the arrays of knowns, unknowns and constants, but the associated net list object is copied only by reference. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new table is returned. Some memory has been allocated on the heap; therefore the object needs to be deleted again after usage. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>The number of knowns to store in the table. This number needs to be precisely known at time of creation: Adding elements is only double-checked by assertion in the DEBUG compilation.object to copy is passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>

</div>
</div>
<a class="anchor" id="abf74786ef478ab7dbe6cde4a62fddc26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a reference to a table of variables. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with tbv_deleteTableOfVariables after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the passed pointer <em>pTabOfVars</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTabOfVars</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a6381ee040e21d959be597981e152160e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a>* tbv_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a reference to a constant table of variables. The new reference is counted internally for later and safe control of the delete operation.<br/>
 Any requested reference needs to be freed with tbv_deleteTableOfVariables after use. </p>
<dl class="section return"><dt>Returns</dt><dd>A read-only copy of the passed pointer <em>pTabOfVars</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTabOfVars</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
void tbv_deleteTableOfVariables(tbv_tableOfVariables_t * const) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br/>
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="a54aefd54a051bcc2910a962da903372d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_deleteTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstTabOfVars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a reference to a table of variables after use. If there are no references left then the object itself is deleted, all memory is freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstTabOfVars</td><td>Pointer to the object to be deleted. No action if this is the NULL pointer.<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_createTableOfVariables(unsigned int, unsigned int, unsigned int) </dd>
<dd>
<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *tbv_cloneByReference(<a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Regardless of the destructive operation the object is declared read-only in order to support deletion of read-only copies of references to existing objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a23c7acab587bdb54bc76761b43edc856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_logTableOfVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Diagnostic function: Write the contents of a table of variables object to the application log. Logging is done on level DEBUG. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A reference to the table to be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86e47b2021631fb5761160ee8c830f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_addKnown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a known variable to the table and assign a column of the LES, which holds the coefficients related to this known. </p>
<dl class="section return"><dt>Returns</dt><dd>Success. Failures can be ambiguous names, an overful table or an invalid column index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the table of variables, which the known is to be put into. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the known. Mainly used for reporting results. The string is copied into local memory of the table object. The passed pointer needs to be valid only during function execution. The name must not be NULL or the empty string. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>Knowns are related to devices (constant sources). A lookup function by device index is defined. To support the lookup function the index of the device is passed to this function. The index is related to the linear array of devices in the parse result (i.e. the circuit net list object). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. Errors caused by bad user input are reported to the application log. </dd></dl>

</div>
</div>
<a class="anchor" id="a61a404154eaab98112f030a33e75b6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_addUnknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idSubNet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an unknown variable to the table and assign a column of the LES, that holds the coefficients related to this unknown. </p>
<dl class="section return"><dt>Returns</dt><dd>Success. Failures can be ambiguous names, an overful table or an invalid node or device index. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the half-way completed table of variables, which the unknown is to be put into. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the unknown. Mainly used for reporting results. The string is copied into local memory of the table object. The passed pointer needs to be valid only during function execution. The name must not be NULL or the empty string. </td></tr>
    <tr><td class="paramname">idxNode</td><td>Most unknowns are voltages of nodes of the network. For these a lookup function by node is defined. To support the lookup function the index of the node is passed to this function. The index is related to the linear array of nodes in the parse result. Unknowns, that are not node voltages specify <a class="el" href="pci__parser_circuit_8h.html#a7f3fdcf0d9f687563edc266fe2457978">PCI_NULL_NODE</a>. </td></tr>
    <tr><td class="paramname">idSubNet</td><td>If idxNode is not <a class="el" href="pci__parser_circuit_8h.html#a7f3fdcf0d9f687563edc266fe2457978">PCI_NULL_NODE</a> then the ID of the sub-graph of the complete circuit is passed. All sub-graphs have a unique ID. The value UINT_MAX is reserved and must not be used as ID. Instead, pass UINT_MAX if the unknown is related to a device rather than to a node's voltage potential. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>Unknowns, which are not voltages of nodes of the network are related to devices (device currents mostly). For these a lookup function by device index is defined. To support the lookup function the index of the device is passed to this function. The index is related to the linear array of devices in the parse result. Unknowns, that are not device related specify <a class="el" href="pci__parser_circuit_8h.html#a998c4b91c0dd27119fded70db5220bbb">PCI_NULL_DEVICE</a>.<br/>
 Either <em>idxNode</em> or <em>idxDevice</em> is specified but not both at a time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. Errors caused by bad user input are reported to the application log. </dd></dl>

</div>
</div>
<a class="anchor" id="a03935de59128a8b5b0950295b123b581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_addConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a physical device constant to the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the table of variables, which the constant is to be put into. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>A device's constant is closely related to the device. The table therefore holds the reference to a device object instead of a dedicated object to represent the constant.<br/>
 The reference is implemented as the index of the device in the array of devices inside the parse result. (A read-only copy of the parse result is found inside the object * <em>pTable</em>.) The index refers to this table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An error because of an overful table is reported by assertion only as it is considered an internal implementation error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d90b517ec9c3808eb5d6e02a208b0f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_sortConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After having added all device constants with <em>tbv_addConstant</em> but prior to using the shaped association between a constant's name and its internal representation as a <em>coe_productOfConst_t</em> the very first time, the order of the constants in the table may be chosen. With other words: Which constant is associated with bit 0 of the internal representation, which one with bit 1, etc. The order gets apparent in all result output, where the constants with higher bit index are printed first. The most natural order of output of products of constants is R(esistor) before L (inductivity) before C(apacitor). This routine shapes an according order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>A pointer to the object, whose constants are to be sorted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><em>tbv_addConstant</em> should not be called after calling this method; <em>tbv_getConstantByDevice</em>, <em>tbv_getDeviceByBitIndex</em> and <em>tbv_getReferencedDeviceByBitIndex</em> must not be called before calling this method; </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>void <a class="el" href="tbv__table_of_variables_8h.html#a03935de59128a8b5b0950295b123b581">tbv_addConstant(tbv_tableOfVariables_t * const, unsigned int)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a82b3d754a0695ee117defd72a4db8921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tbv_exportAsMCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const&#160;</td>
          <td class="paramname"><em>pMScript</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tbv__table_of_variables_8h.html#a2c0e5fe28a9d36ad30d1555426db8b59">tbv_contextOfMCode_t</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>indentStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the elements that are relevant to the executable Octave code into an M script. As a matter of fact, these are only the values of the device constants. To have executable code in any case the method writes default values to the M script where the input file doesn't specify actual values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the exported table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">pMScript</td><td>The pointer to an M script object. The generated M code is written into this M script. The object is the result of a successful call of boolean msc_createMScript(<a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> ** const, const char * const, const char * const, const char * const). </td></tr>
    <tr><td class="paramname">context</td><td>The variables can be exported in different contexts of M code. Choose, which context to support. </td></tr>
    <tr><td class="paramname">indentStr</td><td>The generated code starts with a new line. This and each other required line will begin with the passed string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Find reasonable default values for controlled voltage sources. What are typical use cases? </dd></dl>

</div>
</div>
<a class="anchor" id="a26f1bac7852f707dc27fa1b9055d7c0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__known_variable__t.html">tbv_knownVariable_t</a>* tbv_getKnownByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for a known variable related to a device (a constant source) in the lookup table of knowns. </p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of the known is returned by reference. If <em>idxDevice</em> is not the index of a device, that defines an known voltage or current in the LES then an assertion fires. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device, the known is related to. The index refers to the array of devices in the parse result. PCI_NULL_DEVICE must not be passed as it is not a unique device identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a738e9acc910c1dee86990e7087ba7e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a>* tbv_getUnknownByNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for an unknown variable by node in the lookup table of those. </p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of the unknown is returned if <em>idxNode</em> represents one of the independent network nodes. If it designates a ground node then NULL is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxNode</td><td>The index of the node, the unknown is related to. The index refers to the array of nodes in the parse result. PCI_NULL_NODE must not be passed as it is not a unique node identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c7162b1123ba15a3eed6367c8733dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtbv__unknown_variable__t.html">tbv_unknownVariable_t</a>* tbv_getUnknownByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for an unknown variable related to a device current in the lookup table of unknowns. </p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of the unknown is returned. If <em>idxDevice</em> is not the index of a device, that defines an unknown current in the LES then an assertion fires. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The index of the device, the unknown is related to. The index refers to the array of devices in the parse result. PCI_NULL_DEVICE must not be passed as it is not a unique device identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84fe5c8471002f477b82b2eada152b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="coe__coefficient_8h.html#a53d35044911ab7bc1121b47d22e7e82c">coe_productOfConst_t</a> tbv_getConstantByDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for a constant in the lookup table of those. The constant is identified by the index of the device the constant belongs to. </p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of the constant is returned. It's a bit vector with a single set bit; this bit represents the constant. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxDevice</td><td>The reference to the device to look for. A constant needs to be defined for this device (<em>tbv_addConstant</em>). The reference is implemented as the index of the device in the array of devices inside the parse result. (A read-only copy of the parse result is found inside the object * <em>pTable</em>.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a579d2f95cc4204f07dabe345b936d0d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpci__device__t.html">pci_device_t</a>* tbv_getDeviceByBitIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for a device description by the constant representing it. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the device descriptor is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">idxBit</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit is passed as key for the lookup operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a891cb33e9396da854317282fad2eb7f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_getReferencedDeviceByBitIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrat__num__t.html">rat_num_t</a> *&#160;</td>
          <td class="paramname"><em>pRefFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpci__device__t.html">pci_device_t</a> **const&#160;</td>
          <td class="paramname"><em>ppDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pIdxBitRefDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look for the description of the device indirectly referenced by the constant representing a device. Any device's value may be expressed as a product of a constant and the value of another device. This may happen recursively. If such a reference or chain of references is present for the device represented by the passed constant, than the last device in the chain of references is returned, together with the factor of the values. </p>
<dl class="section return"><dt>Returns</dt><dd>The other return values are valid only if the function returns true. If an error occurs a message is written to the global application and false is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The reference to the filled table of symbolic objects is passed. </td></tr>
    <tr><td class="paramname">pRefFactor</td><td>The effective factor of the value of the device directly addressed by <em>idxBit</em> to the value of the finally referenced device ** <em>ppDevice</em>. </td></tr>
    <tr><td class="paramname">ppDevice</td><td>The pointer to the descriptor of the finally referenced device is placed in * <em>ppDevice</em>. In general, this is not the device addressed by <em>idxBit</em>. </td></tr>
    <tr><td class="paramname">pIdxBitRefDev</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit for the finally referenced device is placed in * <em>pIdxBitRefDev</em>. </td></tr>
    <tr><td class="paramname">idxBit</td><td>A device is represented by a "productOfConst" where one and only one bit is set. The index of the set bit is passed as key for the look up operation of the first device in the chain of references. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1b7811ea00b8c3715e2b14d5ef5eacb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tbv_setTargetUnknownForSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameOfUnknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select a specific unknown for result computation.<br/>
 Currently, the solver is not capable to find a solution for all unknowns at once. It returns a fully eliminated solution only for the very unknown, whose coefficients are placed in the rightmost LHS column m of the LES. By simply exchanging two columns of the (later) LES on user demand, we can achieve that any unknown is represented in column m of the LES. Column swapping is what this method actually does. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the desired unknown is known; then the operation succeeds. Otherwise false. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTable</td><td>The assignment of unknowns to columns in the LES is specified in a table of variables. The pointer to such a table is passed. The table is modified in place. </td></tr>
    <tr><td class="paramname">nameOfUnknown</td><td>The unknown is selected by name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a470f8d09d6a16be38c7ac76067642fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> _log = <a class="el" href="log__logger_8h.html#aef9403182a4900c1b62a11082dd7bdb6">LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global logger object is referenced from anywhere for writing progress messages. </p>

</div>
</div>
<a class="anchor" id="a470a463163890645f09c7b90f2e1de48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _noRefsToObjects = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global counter of all refernces to any created objects. Used to detect memory leaks. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 23 2014 10:40:27 for linNet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
