<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>linNet: frq_freqDomainSolution.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('frq__freq_domain_solution_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">frq_freqDomainSolution.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="smalloc_8h_source.html">smalloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="snprintf_8h_source.html">snprintf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log__logger_8h_source.html">log_logger.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="coe__coefficient_8inline_interface_8h_source.html">coe_coefficient.inlineInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sol__solver_8h_source.html">sol_solver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="crm__create_matrix_8h_source.html">crm_createMatrix.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="frq__freq_domain_solution_8h_source.html">frq_freqDomainSolution.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="msc__m_script_8h_source.html">msc_mScript.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="frq__freq_domain_solution_8inline_interface_8h_source.html">frq_freqDomainSolution.inlineInterface.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3f4ca74e7d2938ddd80e188a324340d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a3f4ca74e7d2938ddd80e188a324340d4">RESULT_EXPR_REF_IS_NEGATED</a>&#160;&#160;&#160;((UINT_MAX)-(INT_MAX))</td></tr>
<tr class="separator:a3f4ca74e7d2938ddd80e188a324340d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a4fc34b120ed3bd1120c1eb36abbcd6af">NL</a>&#160;&#160;&#160;&quot; char(10) ...\n&quot;</td></tr>
<tr class="separator:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d72b72592cc30afbd4422632aa9c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a73d72b72592cc30afbd4422632aa9c4c">IND</a>&#160;&#160;&#160;&quot;          &quot;</td></tr>
<tr class="separator:a73d72b72592cc30afbd4422632aa9c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4864e851c25b3a6758293009ffa18730"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak" />
resultExpressionOrigin_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a4864e851c25b3a6758293009ffa18730">resultExpressionOrigin_t</a></td></tr>
<tr class="separator:a4864e851c25b3a6758293009ffa18730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c55995eda80531fd4a74431c4225b6"><td class="memItemLeft" align="right" valign="top">typedef struct resultExpression_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a57c55995eda80531fd4a74431c4225b6">resultExpression_t</a></td></tr>
<tr class="separator:a57c55995eda80531fd4a74431c4225b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1dd383815d3797012f77d22757829b"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak" />
resultExpressionMap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a></td></tr>
<tr class="separator:a1a1dd383815d3797012f77d22757829b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c11f32d5378230cb4f56c8d2d26b26b"><td class="memItemLeft" align="right" valign="top">static <br class="typebreak" />
<a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a1c11f32d5378230cb4f56c8d2d26b26b">expressionAddendNull</a> ()</td></tr>
<tr class="separator:a1c11f32d5378230cb4f56c8d2d26b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438c701ec0fcdcc873951f423fa6777"><td class="memItemLeft" align="right" valign="top">static <br class="typebreak" />
<a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ad438c701ec0fcdcc873951f423fa6777">expressionAddendOne</a> ()</td></tr>
<tr class="separator:ad438c701ec0fcdcc873951f423fa6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d1a6d3f8cd976924fedc6ca987d21"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a525d1a6d3f8cd976924fedc6ca987d21">isExpressionAddendNull</a> (const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pAddend)</td></tr>
<tr class="separator:a525d1a6d3f8cd976924fedc6ca987d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecad9d6ed0ae6af504322ab5c8d25850"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aecad9d6ed0ae6af504322ab5c8d25850">freeExpressionAddend</a> (const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pExpressionAddend)</td></tr>
<tr class="separator:aecad9d6ed0ae6af504322ab5c8d25850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aecf047d76d041a1c4f66466d07cc0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a9aecf047d76d041a1c4f66466d07cc0b">freeExpression</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpression)</td></tr>
<tr class="separator:a9aecf047d76d041a1c4f66466d07cc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efaa7129c0ebb80ef11112bf85aa65b"><td class="memItemLeft" align="right" valign="top">static <br class="typebreak" />
<a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a0efaa7129c0ebb80ef11112bf85aa65b">normalizedExpressionNull</a> ()</td></tr>
<tr class="separator:a0efaa7129c0ebb80ef11112bf85aa65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c0b127f1b8dc0b6aaae579947bb79f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ab6c0b127f1b8dc0b6aaae579947bb79f">isNormalizedExpressionNull</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const pExpr)</td></tr>
<tr class="separator:ab6c0b127f1b8dc0b6aaae579947bb79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62635ffd06670979c1b560760c644c66"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a62635ffd06670979c1b560760c644c66">freeNormalizedExpression</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const pExpression)</td></tr>
<tr class="separator:a62635ffd06670979c1b560760c644c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa3e86989a14c20db57c928af8e1c0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a50aa3e86989a14c20db57c928af8e1c0">freeConstString</a> (const char *const string)</td></tr>
<tr class="separator:a50aa3e86989a14c20db57c928af8e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6860727de9ffb83f97e1f48d644b6c"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a1f6860727de9ffb83f97e1f48d644b6c">getNoAddendsOfSamePowerOfS</a> (const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *pAddend)</td></tr>
<tr class="separator:a1f6860727de9ffb83f97e1f48d644b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfcee758a993947b3b350e4f904bf20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aecfcee758a993947b3b350e4f904bf20">isEqualExpressions</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *pOp1, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *pOp2, const unsigned int noConst)</td></tr>
<tr class="separator:aecfcee758a993947b3b350e4f904bf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b1755dfaadf9f6f9190e25d323137b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a89b1755dfaadf9f6f9190e25d323137b">isAbsEqualExpressions</a> (<a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *const pHaveSameSign, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *pOp1, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *pOp2, const unsigned int noConst)</td></tr>
<tr class="separator:a89b1755dfaadf9f6f9190e25d323137b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f58003544d40f3415c5eb5bf22530e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ab8f58003544d40f3415c5eb5bf22530e">mulByAddendAndCpy</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpression, const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pFactor, unsigned int noConst)</td></tr>
<tr class="separator:ab8f58003544d40f3415c5eb5bf22530e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b40accd905ac9bb97ce2c049b3575f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a7b40accd905ac9bb97ce2c049b3575f4">divByAddend</a> (<a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpression, const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pDivisor, const unsigned int noConst)</td></tr>
<tr class="separator:a7b40accd905ac9bb97ce2c049b3575f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd8f4db58abd2126296a04043367a25"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a7dd8f4db58abd2126296a04043367a25">addAddendToExpr</a> (<a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const ppExpression, <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pNewFreqDomainAddend, const unsigned int noConst)</td></tr>
<tr class="separator:a7dd8f4db58abd2126296a04043367a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16c942ec401dcb31e38ddad1a5d5daa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aa16c942ec401dcb31e38ddad1a5d5daa">initializeNameArys</a> (<a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution)</td></tr>
<tr class="separator:aa16c942ec401dcb31e38ddad1a5d5daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13d8f12a612b85f5d4e6c78d75818c3"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ab13d8f12a612b85f5d4e6c78d75818c3">getNameOfNumerator</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, unsigned int idxDependent, unsigned int idxIndependent)</td></tr>
<tr class="separator:ab13d8f12a612b85f5d4e6c78d75818c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38932c9576e62c93e89bb4653157d10"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#af38932c9576e62c93e89bb4653157d10">getNameOfDenominator</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, unsigned int idxDependent, unsigned int idxIndependent)</td></tr>
<tr class="separator:af38932c9576e62c93e89bb4653157d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088dc2205a24953f18c41f7e1b60f94d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a088dc2205a24953f18c41f7e1b60f94d">transformAddend</a> (<a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> **const ppFrqDomExpressionAddend, const <a class="el" href="structcoe__coef_addend__t.html">coe_coefAddend_t</a> *const pAlgebraicAddend, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars)</td></tr>
<tr class="separator:a088dc2205a24953f18c41f7e1b60f94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a60561e3a12ee948a781927056f70c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a49a60561e3a12ee948a781927056f70c">getNormalizationFactor</a> (<a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> **const ppNormAddend, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpression, const unsigned int noConst)</td></tr>
<tr class="separator:a49a60561e3a12ee948a781927056f70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83dc36210dca49506ae125f6b4ed8a8"><td class="memItemLeft" align="right" valign="top">static <br class="typebreak" />
<a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aa83dc36210dca49506ae125f6b4ed8a8">createNormalizedExpression</a> (<a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpression, const unsigned int noConst)</td></tr>
<tr class="separator:aa83dc36210dca49506ae125f6b4ed8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98993ac68eec6a733eb92ee3b5e58fa7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a98993ac68eec6a733eb92ee3b5e58fa7">transformExpression</a> (<a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> **const ppFrqDomExpression, const <a class="el" href="coe__coefficient_8h.html#aed0d35df49608d13b552b76dbb518871">coe_coef_t</a> *const pAlgebraicExpr, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars)</td></tr>
<tr class="separator:a98993ac68eec6a733eb92ee3b5e58fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64a8cd9cdee117111f30bf4710c41ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ab64a8cd9cdee117111f30bf4710c41ae">getBlankTabString</a> (char *const extendedTabString, unsigned int sizeOfExtendedTabString, const char *const existingTabString, unsigned int additionalIndentation)</td></tr>
<tr class="separator:ab64a8cd9cdee117111f30bf4710c41ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd356d94623a3bf4c6ac7fb18396f37"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#adcd356d94623a3bf4c6ac7fb18396f37">print</a> (FILE *stream, const char *const formatString,...)</td></tr>
<tr class="separator:adcd356d94623a3bf4c6ac7fb18396f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07e90ae0b4faff3d0f6da55cde6448"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a8f07e90ae0b4faff3d0f6da55cde6448">printExpression</a> (FILE *const stream, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpr, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, const unsigned int printMargin, const char *const tabString)</td></tr>
<tr class="separator:a8f07e90ae0b4faff3d0f6da55cde6448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b303b2c2b7b42fb286e4ea8de4285e"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak" />
<a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a51b303b2c2b7b42fb286e4ea8de4285e">printCoefInSAsMCode</a> (FILE *const stream, const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const pHeadOfGroup, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, const unsigned int printMargin, const char *const tabString)</td></tr>
<tr class="separator:a51b303b2c2b7b42fb286e4ea8de4285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bf33c13e4533a9de8c48d904f40057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aa1bf33c13e4533a9de8c48d904f40057">isExpressionSimple</a> (const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpr, const unsigned int noConst)</td></tr>
<tr class="separator:aa1bf33c13e4533a9de8c48d904f40057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121b315ebcad95f5a74ef9f62a9e14d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a121b315ebcad95f5a74ef9f62a9e14d9">printNamedExpression</a> (FILE *const stream, const char *const name, const char *const nameRHS, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpr, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> invertSign, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, const unsigned int printMargin, const char *const tabString)</td></tr>
<tr class="separator:a121b315ebcad95f5a74ef9f62a9e14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9f9a2e94e86e679217270ea916e04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ac2d9f9a2e94e86e679217270ea916e04">printNamedExpressionAsMCode</a> (FILE *const stream, const char *const name, const char *const nameRHS, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpr, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> invertSign, const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const pTableOfVars, const unsigned int printMargin)</td></tr>
<tr class="separator:ac2d9f9a2e94e86e679217270ea916e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b557b5499da28e87aa095932645e6a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ac9b557b5499da28e87aa095932645e6a">cancelFraction</a> (<a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const ppCancelledExprNum, <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const ppCancelledExprDenom, const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const pNExprNum, const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const pNExprDenom, const unsigned int noConst)</td></tr>
<tr class="separator:ac9b557b5499da28e87aa095932645e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbd8b2a1ef260913124eb28e0cf62e1"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a1dbd8b2a1ef260913124eb28e0cf62e1">moveExprIntoMap</a> (<a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pMap, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const pExpr, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isUsedAsDenominator)</td></tr>
<tr class="separator:a1dbd8b2a1ef260913124eb28e0cf62e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9177007b028e8ba1fa31c5130eb7eee4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a9177007b028e8ba1fa31c5130eb7eee4">createExpressionMap</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution)</td></tr>
<tr class="separator:a9177007b028e8ba1fa31c5130eb7eee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b79eadc81e023c49016ed44b16ee87e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a9b79eadc81e023c49016ed44b16ee87e">deleteExpressionMap</a> (<a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pExprMap)</td></tr>
<tr class="separator:a9b79eadc81e023c49016ed44b16ee87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9bdf5ac2c81807208b4e9c7c91581d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a4e9bdf5ac2c81807208b4e9c7c91581d">setNameOfExpression</a> (<a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pExprMap, const <a class="el" href="frq__freq_domain_solution_8c.html#a4864e851c25b3a6758293009ffa18730">resultExpressionOrigin_t</a> *const pOrigin)</td></tr>
<tr class="separator:a4e9bdf5ac2c81807208b4e9c7c91581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def88000faf3e6541aeb977f4ae9b00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a3def88000faf3e6541aeb977f4ae9b00">setExpressionNames</a> (<a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pExprMap, unsigned int idxDependentAry[])</td></tr>
<tr class="separator:a3def88000faf3e6541aeb977f4ae9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a4d2f6886beff57cdb14979103d619"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a19a4d2f6886beff57cdb14979103d619">determineOrderOfRendering</a> (<a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pExprMap, unsigned int idxDependentAry[])</td></tr>
<tr class="separator:a19a4d2f6886beff57cdb14979103d619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d39da182b5a8a1d5e5a121932f0343"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a06d39da182b5a8a1d5e5a121932f0343">getExpression</a> (const <a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const pExprMap, const char **const pName, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *const pIsExpressionNegated, const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const ppExpression, unsigned int idxDependent, unsigned int idxIndependent, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isNumerator)</td></tr>
<tr class="separator:a06d39da182b5a8a1d5e5a121932f0343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21747563cf45461c69c1bf6b5f36f3d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a21747563cf45461c69c1bf6b5f36f3d3">printSolution</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, FILE *const stream, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> asOctaveCode, const unsigned int printMargin)</td></tr>
<tr class="separator:a21747563cf45461c69c1bf6b5f36f3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b19bd78eeec5514a5cfb92f0d9398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#aa78b19bd78eeec5514a5cfb92f0d9398">frq_initModule</a> (<a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hLogger)</td></tr>
<tr class="separator:aa78b19bd78eeec5514a5cfb92f0d9398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0472bee087281ba40c57294aa3cc08d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a0472bee087281ba40c57294aa3cc08d3">frq_shutdownModule</a> ()</td></tr>
<tr class="separator:a0472bee087281ba40c57294aa3cc08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7badefe4e527d428b779b657ca3ee489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a7badefe4e527d428b779b657ca3ee489">frq_createFreqDomainSolution</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> **const ppFrqDomSolution, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const pAlgebraicSolution, signed int idxResult)</td></tr>
<tr class="separator:a7badefe4e527d428b779b657ca3ee489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51362b03bae7fc0508ddc6f78e6ee813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a51362b03bae7fc0508ddc6f78e6ee813">frq_cloneByReference</a> (<a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:a51362b03bae7fc0508ddc6f78e6ee813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b7fa0e60d6c5f1cabcbf7ad1ec2ad8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#af8b7fa0e60d6c5f1cabcbf7ad1ec2ad8">frq_cloneByConstReference</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pExistingObj)</td></tr>
<tr class="separator:af8b7fa0e60d6c5f1cabcbf7ad1ec2ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb94ced2700d2ce1416b0f72914fce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a5bb94ced2700d2ce1416b0f72914fce4">frq_deleteFreqDomainSolution</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pConstFreqDomainSolution)</td></tr>
<tr class="separator:a5bb94ced2700d2ce1416b0f72914fce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed36d443d483179212c72914eaed81a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a2ed36d443d483179212c72914eaed81a">frq_getNameOfIndependent</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, unsigned int idxIndependent)</td></tr>
<tr class="separator:a2ed36d443d483179212c72914eaed81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e3f7c9f0658fe36cd9267a1b644a94"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a31e3f7c9f0658fe36cd9267a1b644a94">frq_getNameOfDependent</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, unsigned int idxDependent)</td></tr>
<tr class="separator:a31e3f7c9f0658fe36cd9267a1b644a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee8ebc66f1330fe481a6c32fc6fae79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#a0ee8ebc66f1330fe481a6c32fc6fae79">frq_logFreqDomainSolution</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, <a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a> hLog, <a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a> logLevel)</td></tr>
<tr class="separator:a0ee8ebc66f1330fe481a6c32fc6fae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bd6c2c81e26c6f3149e4a36fc2deed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frq__freq_domain_solution_8c.html#ab6bd6c2c81e26c6f3149e4a36fc2deed">frq_exportAsMCode</a> (const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const pSolution, <a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const pMScript)</td></tr>
<tr class="separator:ab6bd6c2c81e26c6f3149e4a36fc2deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representation of a computed algebraic solution of the LES in the frequency domain.<br />
Design considerations:<br />
 The input to a frequency domain solution is a full algebraic solution. Full means, we have a result expression for each unknown, which are all unknowns of the LES plus user-defined voltages, which are sums of the former. The first thing we do is to take a sub-set of <em>m</em> of these unknowns, according to the user-defined result. All further steps are done to the unknowns of this sub-set and all other unknowns are simply ignored.<br />
 The frequency solution object (frq object) shapes an rectangular array of <em>m</em> times <em>n</em> normalized numerators plus a normalized common denominator. (<em>n</em> is the number of knowns or system inputs). The result expression of each of the <em>m</em> unknowns has <em>n</em> addends, where each addend is the quotient of the according numerator and the common denominator times the according known.<br />
 Each of the <em>m</em> * <em>n</em> +1 expressions is a frequency domain expression; it is a sum of addends, where each addend is the product of a rational number, the device constants (mainly R, L, C) to their individual powers and s to its individual power. The addends have been derived by a straightforward transformation from the addends of the algebraic solution. The latter use set bits for the presence of a device in a product and the rational coefficient of the addend is just a sign, i.e. either one or minus one. A present device always means the complex conductivity of that device. In the frq object, this conductivity is explicitly expressed, by substituting an R by 1/R, a C by C*s or an L by 1/(L*s). Furthermore, if a device constant is specified as a relation to another one, like R2=2*R1, than this relation is inserted into the transformed expression. This is, where individual powers of device constants other than 0, +1 or -1 and numeric coefficients other than +1 or -1 result from. This transformation ends up with the previously described form of addends, where all individual powers are signed.<br />
 A normalized expression is derived from the result expression of the transformation described in the previous paragraph by determining a factor such that the remaining expression has a minimum individual power of null for each device constant and for the frequency variable s. Where "minimum" is meant across all addends of the expression. There will be at least one addend having s^0, one (other) addend having R1^0, one (other) addend having R2^0, and on so on. Negative powers do no longer occur. Moreover, "normalized" means, that the numeric coefficient of each addend, which is an arbitrary rational number prior to normalization, becomes a signed integer number, i.e. the denominator of this coefficient is one. The product of the determined factor and the remaining expression is identical to the result expression of the transformation described in the previous paragraph.<br />
 The rest of the computation is done as part of the result representation, in the output functions either as human readable text or as Octave script code.<br />
 One result expression is written per unknown. It is basically a list of quotients of two of the normalized expressions. The list has as many elements as there are system inputs. (In the output the list elements are concatenated by purely static, trivial context. The Octave code requires vectors of the list elements by separating semicolons and embracing rectangular brackets and the human readable text will insert the operator</p><ul>
<li>and the product with the named system input.)<br />
 The first pass of the result output iterates over all quotients. Comparing the normalization factors of numerator and denominator it's straightforward to find the common terms for cancellation of the ratio. The remaining expressions are only checked for identity; they can be canceled in their entirety if so. (There's no chance to find more complex common divisors.) After cancellation the two expressions are denormalized by multiplying the canceled normalization factors into the remaining expressions. It's guaranteed that both expressions still have individual powers greater or equal to null and numeric coefficients with denominator one. (Cancellation has been done accordingly.)<br />
 To find common terms, the two expressions are put into a map of such and this addend of the result is now represented as a pair of references to the two expressions in the map.<br />
 Inserting into the map means the expressions are compared to each of the already contained expressions. If found the reference to the existing expression is returned, if not the expression is added and the reference to the new map entry is returned. Furthermore, the map entry has a Boolean indication, if a stored expression is used by at least one denominator. When entering the denominator expression, this flag is set to true for the according stored expression.<br />
 All expressions are printed as assignments in the form: symbol name, operator =, right hand side (RHS). Reusing expressions means that RHS is either printed as an expression in all details or by referencing the name of the first assignment, where this expression was already used. It's convenient for human readable output and essential for Octave script output that references appear only by back references (references to already printed assignments). Furthermore, it's convenient to preferably have references to already used denominators rather than to already used numerators. To meet these demands we do the actual output in two addition passes.<br />
 In the next pass we iterate over all unknowns and all of their terms. (Such a term is a quotient, represented by a pair of references into the expression map.) Each element in the map has a field name, which is empty at the beginning of this pass and which will hold the symbol name used for this expression. If - for the unknown under progress - all referenced numerators either have a non empty name field or they are marked not to be referenced by at least one denominator, then this result is written. The output uses expression writing in all details as RHS if the name field is still empty or the name as RHS otherwise. If the name field had been empty then the name of the numerator or denominator the expression is assigned to is entered as name of the expression in this field. The unknown is marked as already handled.<br />
 In the next pass we iterate over all not yet handled unknowns. The result is now written unconditionally. If a name field of a denominator is still empty, then the name of this denominator is inserted (and the insertion is kept in mind). For each term (quotient) numerator and denominator expressions are written. If a numerator name field is still empty then the name of this numerator is entered and the RHS is written in all details. Otherwise the RHS is just the already contained name. If a denominators name had been entered in this pass than the RHS is written in all details otherwise just as the already contained name.<br />
 The two passes of output are slightly modified to optimize a very frequent situation. Often, all terms of all the unknowns have the exactly same denominator (as individual canceling is impossible). In this case, it's more convenient to write this denominator only once at the beginning (in all details). This is done if there's only one expression marked as referenced by a denominator and at least two result terms (i.e. the number of unknowns or the number of system inputs is greater than one).</li>
</ul>
<p>Copyright (C) 2013-2014 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3f4ca74e7d2938ddd80e188a324340d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESULT_EXPR_REF_IS_NEGATED&#160;&#160;&#160;((UINT_MAX)-(INT_MAX))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The index into the linear array of stored, reusable expressions can be tagged with a set MSB. This bit indicates that the stored expression is the negated, actual expression. </p>

</div>
</div>
<a class="anchor" id="a4fc34b120ed3bd1120c1eb36abbcd6af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NL&#160;&#160;&#160;&quot; char(10) ...\n&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a73d72b72592cc30afbd4422632aa9c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IND&#160;&#160;&#160;&quot;          &quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4864e851c25b3a6758293009ffa18730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct resultExpressionOrigin_t  resultExpressionOrigin_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The origin of a result expression means the address of the term of a frequency domain solution, which was name giving to the result expression. If several such terms are identical, then only one of them will be the name giving one. This term is addressed to by index of dependent, index of independent and the distinction between numerator and denominator. </p>

</div>
</div>
<a class="anchor" id="a57c55995eda80531fd4a74431c4225b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct resultExpression_t  resultExpression_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The result representation uses a map of (reusable) expressions, the solution is composed from. </p>

</div>
</div>
<a class="anchor" id="a1a1dd383815d3797012f77d22757829b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct resultExpressionMap_t  resultExpressionMap_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prior to a textual representation, the solution is brought into this structure. It supports cancelled fractions and reuse of same expressions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1c11f32d5378230cb4f56c8d2d26b26b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a>* expressionAddendNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a addend object, that represents null. It has been allocated using the global heap mem_hHeap_t _hHeapOfAddends and needs to be freed after use with void <a class="el" href="mem__memory_manager_8c.html#a0def23182a64f28d82a7c9c1937f3de1">mem_free(heap_t *, void *)</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get a pointer to the new object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad438c701ec0fcdcc873951f423fa6777"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a>* expressionAddendOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an addent of a addend object, that represents 1. It has been allocated using the global heap mem_hHeap_t _hHeapOfAddends and needs to be freed after use with void <a class="el" href="mem__memory_manager_8c.html#a0def23182a64f28d82a7c9c1937f3de1">mem_free(heap_t *, void *)</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get a pointer to the new object. </dd></dl>

</div>
</div>
<a class="anchor" id="a525d1a6d3f8cd976924fedc6ca987d21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isExpressionAddendNull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pAddend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the addend of an expression if it represents null. </p><dl class="section return"><dt>Returns</dt><dd>Get the Boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="aecad9d6ed0ae6af504322ab5c8d25850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void freeExpressionAddend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpressionAddend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a single addent of a addend object which had been allocated with <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *newExpressionAddend(). If the addend is part of a linked list of addends, then the followers of the deleted addend are ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpressionAddend</td><td>The pointer to the freed addend object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aecf047d76d041a1c4f66466d07cc0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void freeExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0efaa7129c0ebb80ef11112bf85aa65b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> normalizedExpressionNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an expression, that represents null. Its addends have been allocated using the global heap mem_hHeap_t _hHeapOfAddends and need to be freed after use with void <a class="el" href="mem__memory_manager_8c.html#a0def23182a64f28d82a7c9c1937f3de1">mem_free(heap_t *, void *)</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get a pointer to the new object. After use, it has to be deleted with <em>freeNormalizedExpression</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c0b127f1b8dc0b6aaae579947bb79f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isNormalizedExpressionNull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check a normalized expression object if it represents 0. </p><dl class="section return"><dt>Returns</dt><dd>Get the Boolean answer. </dd></dl>

</div>
</div>
<a class="anchor" id="a62635ffd06670979c1b560760c644c66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void freeNormalizedExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a complete, normalized frequency domain expression, which has a factor addend and the remaining expression, which is a linked list of addends that had all been allocated with <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *newExpressionAddend(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpression</td><td>The pointer to the freed normalized expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50aa3e86989a14c20db57c928af8e1c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void freeConstString </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a string as generated by e.g. stralloccpy. Actually a free of the stdlib but the function argument permits to pass a const char* without a compiler warning complaining about discarding type qualifiers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The pointer to the malloc allocated character string to be freed again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f6860727de9ffb83f97e1f48d644b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int getNoAddendsOfSamePowerOfS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *&#160;</td>
          <td class="paramname"><em>pAddend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look ahead while printing an expression: Peek into the list of addends how many addends form a sub-sequence of terms with identical power of the frequency variable. This information is used for grouping addends. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of addends, which is greater or equal to 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pAddend</td><td>This addend is the reference and count one. Its successor are looked for the same power in s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecfcee758a993947b3b350e4f904bf20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isEqualExpressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td>
          <td class="paramname"><em>pOp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td>
          <td class="paramname"><em>pOp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two frequency domain expressions on equality. The operand expressions are lists of addends, not normalized expression objects. </p><dl class="section return"><dt>Returns</dt><dd>true if expressions are identical, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pOp1</td><td>The first operand, or the pointer to its heading addend. </td></tr>
    <tr><td class="paramname">pOp2</td><td>The second operand, or the pointer to its heading addend. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89b1755dfaadf9f6f9190e25d323137b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isAbsEqualExpressions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *const&#160;</td>
          <td class="paramname"><em>pHaveSameSign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td>
          <td class="paramname"><em>pOp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *&#160;</td>
          <td class="paramname"><em>pOp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two frequency domain expressions on absolute equality. The operand expressions are lists of addends, not normalized expression objects. </p><dl class="section return"><dt>Returns</dt><dd>true if expressions are absolute identical, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHaveSameSign</td><td><em>true</em> is placed in * <em>pHaveSameSign</em> if the expressions are entirely identical, false otherwise. </td></tr>
    <tr><td class="paramname">pOp1</td><td>The first operand, or the pointer to its heading addend. </td></tr>
    <tr><td class="paramname">pOp2</td><td>The second operand, or the pointer to its heading addend. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8f58003544d40f3415c5eb5bf22530e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a>* mulByAddendAndCpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Product of expression and a factor, which is a single addend. Similar to <em>mulByAddend</em> but the operation creates a new result object.<br />
 </p><dl class="section return"><dt>Returns</dt><dd>Get the product of the expression * <em>pExpression</em> and the addend * <em>pFactor</em> as a new denormalized expression object. It has to be freed after use. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpression</td><td>The operand expression, which is not changed. </td></tr>
    <tr><td class="paramname">pFactor</td><td>The other operand, the addend to multiply by. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b40accd905ac9bb97ce2c049b3575f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a>* divByAddend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pDivisor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide a frequency domain expression by a constant addend. The first operand is a list of expression addends, not a normalized expression object.<br />
 The operand is manipulated in place. </p><dl class="section return"><dt>Returns</dt><dd>Get the result as return value, too. The pointer <em>pExpression</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpression</td><td>The operand expression prior to the call and the result after return. </td></tr>
    <tr><td class="paramname">pDivisor</td><td>The other operand, the addend to divide by. Must not be null. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dd8f4db58abd2126296a04043367a25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void addAddendToExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const&#160;</td>
          <td class="paramname"><em>ppExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pNewFreqDomainAddend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a single addend to an expression. The expression is changed in place. It is an ordinary, not normalized exression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppExpression</td><td>The manipulated expression is passed as a pointer to the pointer of its head addend. May be a null expression. </td></tr>
    <tr><td class="paramname">pNewFreqDomainAddend</td><td>The addend to add is passed by reference. It may be a null addend. The manipulated expression takes ownership of the object, the caller must no longer use or reference it after return. Particularly, he must not free the addend object. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa16c942ec401dcb31e38ddad1a5d5daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initializeNameArys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Part of creation of a <em><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a></em> object: The names of the expressions that form numerators and denominators of the solution are derived from the names of dependents and independents and are stored for later use.<br />
 The other functions <em>getNameOfNumerator</em> and <em>getNameOfDenominator</em> provide direct access to such a preallocated name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The half-way completed object under creation. Memory allocation for the string pointers had already been done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>const char *getNameOfNumerator( const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> * const, unsigned, unsigned) </dd>
<dd>
const char *getNameOfDenominator( const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> * const, unsigned, unsigned) </dd></dl>

</div>
</div>
<a class="anchor" id="ab13d8f12a612b85f5d4e6c78d75818c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* getNameOfNumerator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of a numerator expression as used in the terms of a solution. </p><dl class="section return"><dt>Returns</dt><dd>Get the name as a read-only string. The returned character pointer points into the solution object and is valid as long as the solution object itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. </td></tr>
    <tr><td class="paramname">idxDependent</td><td>The index of the dependent, which is identical to the index of the solutions held in this object. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent or known. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af38932c9576e62c93e89bb4653157d10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* getNameOfDenominator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of a denominator expression as used in the terms of a solution. </p><dl class="section return"><dt>Returns</dt><dd>Get the name as a read-only string. The returned character pointer points into the solution object and is valid as long as the solution object itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. </td></tr>
    <tr><td class="paramname">idxDependent</td><td>The index of the dependent, which is identical to the index of the solutions held in this object. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent or known. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a088dc2205a24953f18c41f7e1b60f94d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> transformAddend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> **const&#160;</td>
          <td class="paramname"><em>ppFrqDomExpressionAddend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcoe__coef_addend__t.html">coe_coefAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pAlgebraicAddend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a single addend of an algebraic expression into an equivalent addend of a frequency domain expression. The physical value of the devices constants is substituted by the complex conductance value of the given device. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if the transformation could be done, <em>false</em> otherwise. An error report has been written to the global application log if <em>false</em> should be returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppFrqDomExpressionAddend</td><td>The pointer to the transformed expression addend is returned in * <em>ppFrqDomExpressionAddend</em>. The addend is newly allocated and needs to be freed after use.<br />
 A null addend is returned in case of errors. </td></tr>
    <tr><td class="paramname">pAlgebraicAddend</td><td>The transformed algebraic addend. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of variables holds all information about the constants and devices they describe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49a60561e3a12ee948a781927056f70c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getNormalizationFactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> **const&#160;</td>
          <td class="paramname"><em>ppNormAddend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the normalization factor for a denormalized expression. The expression can be represented as the product of this factor and a remaining expression. For the remaining expression holds:<br />
 The powers of device constants and of s are not negative and there's at least one addend which uses power null.<br />
 The numeric coefficient of the addend of the highest power in s is positive.<br />
 The numeric coefficients of all addends are integer numbers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppNormAddend</td><td>The pointer to the addend, which represents the normalization factor, is placed in * <em>ppNormAddend</em>. The addend object is newly created and needs to be freed after use. </td></tr>
    <tr><td class="paramname">pExpression</td><td>A pointer to the expression or to the pointer to its head addend. It must not be the null expression, as the operation is not defined for such. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa83dc36210dca49506ae125f6b4ed8a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a>* createNormalizedExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new, normalized expression object from an existing ordinary expression. </p><dl class="section return"><dt>Returns</dt><dd>A new expression object in normalized form is returned. After use, it is deleted by <em>freeNormalizedExpression</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpression</td><td>An existing expression in not normalized form, i.e. as list of addends.<br />
 The newly created normalized expression object takes the ownership of all elements of the list. After return, these elements must not be touched any more by the caller. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98993ac68eec6a733eb92ee3b5e58fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> transformExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> **const&#160;</td>
          <td class="paramname"><em>ppFrqDomExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="coe__coefficient_8h.html#aed0d35df49608d13b552b76dbb518871">coe_coef_t</a> *const&#160;</td>
          <td class="paramname"><em>pAlgebraicExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform an algebraic expression into an expression in the frequency domain. The algebraic expressions are elements got from the symbolic solver of the LES and the frequency domain expressions are the results wanted by the user. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if the transformation could be done, <em>false</em> otherwise. An error report has been written to the global application log if <em>false</em> should be returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppFrqDomExpression</td><td>The pointer to the transformed expression is returned in * <em>ppFrqDomExpression</em>. An invalid, half-way completed expression is returned in case of errors.<br />
 All the expression's addends are newly allocated and need to be freed after use. </td></tr>
    <tr><td class="paramname">pAlgebraicExpr</td><td>The transformed algebraic expression. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The table of variables holds all information about the physical constants used in the expression and the devices they describe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab64a8cd9cdee117111f30bf4710c41ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getBlankTabString </td>
          <td>(</td>
          <td class="paramtype">char *const&#160;</td>
          <td class="paramname"><em>extendedTabString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfExtendedTabString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>existingTabString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>additionalIndentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a blank tabulator string of given length. Consider a previously existing tabualtor string in case of recusively deepend indentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extendedTabString</td><td>Result of operation: the new combined tabulator string. </td></tr>
    <tr><td class="paramname">sizeOfExtendedTabString</td><td>Size of result char array. No warning if it doesn't fit: The generated tabulator string will silently be truncated. </td></tr>
    <tr><td class="paramname">existingTabString</td><td>A possibly existing tabulator string. It'll prepend the new, blank part of the tabulator string. </td></tr>
    <tr><td class="paramname">additionalIndentation</td><td>Number of blanks in the new, blank part of the generated tabulator string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcd356d94623a3bf4c6ac7fb18396f37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print formatted to a stream. A wrapper around stdio's printf, which suppresses the stream error messages. </p><dl class="section return"><dt>Returns</dt><dd>The number of printed characters as an unsigned number. If the output yields a stream error message the function returns null. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output stream to write to. </td></tr>
    <tr><td class="paramname">formatString</td><td>A printf like format string. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments of the format string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f07e90ae0b4faff3d0f6da55cde6448"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printExpression </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>printMargin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>tabString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print a frequency domain expression. The printed output is not terminated by a final newline. The operand is a list of addends, not a normalized expression object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (as provided by the stdio lib) to write to. </td></tr>
    <tr><td class="paramname">pExpr</td><td>Pointer to the expression. It's a list of addends. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The data structure holding all information about the symbolic elements of the system's equations. </td></tr>
    <tr><td class="paramname">printMargin</td><td>Line wrapping takes place when the margin is exceeded but the currently printed addend of the expression is still not completed. Checking the margin only after completing an addend means that the printed lines can become significantly longer than the margin says. So take a rather small value for the margin. </td></tr>
    <tr><td class="paramname">tabString</td><td>This string is written at the beginning of any wrapped line. Normally the empty or a blank string, but could also contain some comment characters, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51b303b2c2b7b42fb286e4ea8de4285e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a>* printCoefInSAsMCode </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfrq__frq_dom_expression_addend__t.html">frq_frqDomExpressionAddend_t</a> *const&#160;</td>
          <td class="paramname"><em>pHeadOfGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>printMargin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>tabString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a coefficient of a polynomial in s as Ocatve M script code into a text stream. Such a coefficient is a sub-list of addends of a frequency domain expression, where all addends of the sub-list have the same power of s. </p><dl class="section return"><dt>Returns</dt><dd>The methods iterates along the expression's addend list until it reaches the first addend of another (i.e. lower) power of s or the end of the list. The advanced pointer to the visited list element is returned. This may be the list terminating NULL pointer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (as provided by the stdio lib) to write to. </td></tr>
    <tr><td class="paramname">pHeadOfGroup</td><td>Pointer to the first exported addend of the expression. It should be the first addend out of a group of those having the same power of s. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The data structure holding all information about the symbolic elements of the system's equations. </td></tr>
    <tr><td class="paramname">printMargin</td><td>Line wrapping takes place when the margin is exceeded but the currently printed coefficient is still not completed. Checking the margin only after completing an addend means that the printed lines can become significantly longer than the margin says. So take a rather small value for the margin. </td></tr>
    <tr><td class="paramname">tabString</td><td>This string is written at the beginning of any wrapped line. Normally the empty or a blank string, but could also contain some comment characters, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1bf33c13e4533a9de8c48d904f40057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isExpressionSimple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decide if an expression is simple. This function is used for rendering of the results. If an expression has already benn rendered then normally it won't be rendered again. Instead the already printed expression is referenced by name. However, if an expression is simple (in the sense of this function) it would be rendered again rather than referencing an earlier copy. Most popular examples of such simple examples are a null or a one expression.<br />
 </p><dl class="section return"><dt>Returns</dt><dd>Get the boolean statement if the the passed epression is simple. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExpr</td><td>The investigated expression. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a121b315ebcad95f5a74ef9f62a9e14d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printNamedExpression </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>invertSign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>printMargin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>tabString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a frequency domain expression as human readable text into a text stream. The expression is represented as a polynomial in s. The operand is a list of addends, not a normalized expression object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (as provided by the stdio lib) to write to. </td></tr>
    <tr><td class="paramname">name</td><td>This string holds the name of the expression. The output is an assignment like: <em>name</em> = expression; </td></tr>
    <tr><td class="paramname">nameRHS</td><td>The name of a variable, which can be used as expression on the right hand side of the assignment. If NULL is passed or if the expression * <em>pExpr</em> is trivial, then the expression * <em>pExpr</em> is printed as RHS, otherwise only this name (as a reference to an already defined other expression). </td></tr>
    <tr><td class="paramname">pExpr</td><td>Pointer to the expression. It's a list of addends. </td></tr>
    <tr><td class="paramname">invertSign</td><td>To improve reusability of expressions the referenced RHS may have the inverse sign. This is regardless whether the RHS is defined by <em>nameRHS</em> or by <em>pExpr</em>. Pass <em>true</em> if the RHS should be multiplied by -1 prior to printing. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The data structure holding all information about the symbolic elements of the system's equations. </td></tr>
    <tr><td class="paramname">printMargin</td><td>Line wrapping takes place when the margin is exceeded but the currently printed addend of the expression is still not completed. Checking the margin only after completing an addend means that the printed lines can become significantly longer than the margin says. So take a rather small value for the margin. </td></tr>
    <tr><td class="paramname">tabString</td><td>This string is written at the beginning of any wrapped line. Normally the empty or a blank string, but could also contain some comment characters, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2d9f9a2e94e86e679217270ea916e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void printNamedExpressionAsMCode </td>
          <td>(</td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>nameRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>invertSign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtbv__table_of_variables__t.html">tbv_tableOfVariables_t</a> *const&#160;</td>
          <td class="paramname"><em>pTableOfVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>printMargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a frequency domain expression as Ocatve M script code into a text stream. The expression is represented by the vector of coefficients of the polynomial in s, as expected by Octave functions like tf. The operand is a list of addends, not a normalized expression object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (as provided by the stdio lib) to write to. </td></tr>
    <tr><td class="paramname">name</td><td>This string is holds the name of the expression. The output is an assignment like: <em>name</em> = expression; </td></tr>
    <tr><td class="paramname">nameRHS</td><td>The name of a variable to be used as expression on the right hand side of the assignment. Only if NULL is passed, then the complex expression * <em>pExpr</em> is printed as RHS. </td></tr>
    <tr><td class="paramname">pExpr</td><td>Pointer to the expression. It's a list of addends. Ignored if <em>nameRHS</em> is not NULL. </td></tr>
    <tr><td class="paramname">invertSign</td><td>To improve reusability of expressions the referenced RHS may have the inverse sign. This is regardless whether the RHS is defined by <em>nameRHS</em> or by <em>pExpr</em>. Pass <em>true</em> if the RHS should be multiplied by -1 prior to printing. </td></tr>
    <tr><td class="paramname">pTableOfVars</td><td>The data structure holding all information about the symbolic elements of the system's equations. Ignored if <em>nameRHS</em> is not NULL. </td></tr>
    <tr><td class="paramname">printMargin</td><td>Line wrapping takes place when the margin is exceeded but the currently printed addend of the expression is still not completed. Checking the margin only after completing an addend means that the printed lines can become significantly longer than the margin says. So take a rather small value for the margin. Ignored if <em>nameRHS</em> is not NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9b557b5499da28e87aa095932645e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cancelFraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const&#160;</td>
          <td class="paramname"><em>ppCancelledExprNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const&#160;</td>
          <td class="paramname"><em>ppCancelledExprDenom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pNExprNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#aec4111ecc6119314d00ce54277a05241">frq_normalizedFrqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pNExprDenom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>noConst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cancel one result term, i.e. a fraction of one numerator and the common denominator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppCancelledExprNum</td><td>The pointer to the cancelled, denormalized numerator expression is placed into * <em>ppCancelledExprNum</em>. The expressions is newly allocated and needs to be freed after use. </td></tr>
    <tr><td class="paramname">ppCancelledExprDenom</td><td>The pointer to the cancelled, denormalized denominator expression is placed into * <em>ppCancelledExprDenom</em>. The expressions is newly allocated and needs to be freed after use. </td></tr>
    <tr><td class="paramname">pNExprNum</td><td>The pointer to the normalized numerator expression. </td></tr>
    <tr><td class="paramname">pNExprDenom</td><td>The pointer to the normalized denominator expression. </td></tr>
    <tr><td class="paramname">noConst</td><td>The total number of device constants, which are in use in the given system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Here we probably have the operation with highest probability of overflow: The LCM as an intermediate result could be not representable in the shorter int range although the intended final result, the cancelled fraction could still be representable. Shape a test case to find out if we have an (avoidable) bottleneck here </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbd8b2a1ef260913124eb28e0cf62e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int moveExprIntoMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> *const&#160;</td>
          <td class="paramname"><em>pExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>isUsedAsDenominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move a denormalized expression into the map required for result representation. "Move" means, that the map takes the ownership of the passed expression. It'll be freed with destruction of the map. </p><dl class="section return"><dt>Returns</dt><dd>The index under which the expression is found in the map's internal, linear array is returned. The most significant bit has a special meaning: It is set if the referenced expression has to be taken minus one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>The pointer to the map object. All needed storage is preallocated, no memory allocation or free operations take place; the map needs to have enough storage space to complete the operation. </td></tr>
    <tr><td class="paramname">pExpr</td><td>The pointer to the expression or its heading addend. </td></tr>
    <tr><td class="paramname">isUsedAsDenominator</td><td>Boolean flag if this is a numerator or denominator term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9177007b028e8ba1fa31c5130eb7eee4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a>* createExpressionMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an expression map as used for sorted result representation. The map permits to reuse common terms of the solution by giving them a name and referncing this name. Sorting is needed to avoid forward references. </p><dl class="section return"><dt>Returns</dt><dd>The pointer to the new map object is returned. It has been initialized with all initially needed information. After use, it has to be destroyed with <em>deleteExpressionMap</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to be printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b79eadc81e023c49016ed44b16ee87e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void deleteExpressionMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pExprMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy a result expression map after use. Counterpart of <em>createExpressionMap</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExprMap</td><td>Pointer to the object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e9bdf5ac2c81807208b4e9c7c91581d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void setNameOfExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pExprMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8c.html#a4864e851c25b3a6758293009ffa18730">resultExpressionOrigin_t</a> *const&#160;</td>
          <td class="paramname"><em>pOrigin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A private method of the expression map: The origin, i.e. the name giving location of an expression is set. From now on, the expression can be referenced by this name. The assigned name is the name of a numerator or denominator expression as defined for the contained solution object.<br />
 The call is ignored if the expression should already have an origin. Once the origin is defined it cannot be changed any more. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExprMap</td><td>The expression map object to be manipulated. </td></tr>
    <tr><td class="paramname">pOrigin</td><td>The origin of the expression by reference as a set of coordinates into a solution object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3def88000faf3e6541aeb977f4ae9b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void setExpressionNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pExprMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependentAry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A private method of the expression map: Set the names of all the expressions in the expression map. The names are derived from the names of the dependents and independents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExprMap</td><td>The expression map object. </td></tr>
    <tr><td class="paramname">idxDependentAry</td><td>The order of rendering of dependents as figured out by void determineOrderOfRendering(const resultExpressionMap_t * const, unsigned int[]). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19a4d2f6886beff57cdb14979103d619"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void determineOrderOfRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pExprMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependentAry</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A method of the expression map: The order is figured in which the results for the dependent quantities should be printed in order to avoid forward references to repeatedly used expressions.<br />
 The order is returned as index array. The indexes mean the index of the dependent in the solution object of type <em><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a></em>, which the expression map had been created for.<br />
 After figuring out the right order of rendering the expressions, their names are set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExprMap</td><td>The expression map object. </td></tr>
    <tr><td class="paramname">idxDependentAry</td><td>The caller passes the (uninitialized) array to be filled by reference. The array has room for as many indexes as dependents exist in the solution object the map had been created from/for.<br />
 The array indicates only the order of dependents. The order of independents is implicitly defined to be their natural order of index. Furthermore and also implicitly defined is the order of all denominator expressions of a dependent coming before any numerator expression of that dependent.<br />
 Only if all of these ordering aspects are considered during expression rendering then forward references are safely avoided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06d39da182b5a8a1d5e5a121932f0343"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void getExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8c.html#a1a1dd383815d3797012f77d22757829b">resultExpressionMap_t</a> *const&#160;</td>
          <td class="paramname"><em>pExprMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> *const&#160;</td>
          <td class="paramname"><em>pIsExpressionNegated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="frq__freq_domain_solution_8h.html#ae5b0b71aab32388d7bfbc16e38098f09">frq_frqDomExpression_t</a> **const&#160;</td>
          <td class="paramname"><em>ppExpression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>isNumerator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A method of the expression map: An expression is got from the map by index of dependent and independent. The map needs to be filled and all expressions need to have a name, i.e. <em>determineOrderOfRendering</em> must have been called prior to the first call of this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExprMap</td><td>The expression map object to be read from. </td></tr>
    <tr><td class="paramname">pName</td><td>The name of the expression is placed in * <em>pName</em>. The name has been derived from the names of the dependents and independents in the preceding call of <em>determineOrderOfRendering</em>. The name pattern is N_&lt;nameDep&gt;_&lt;nameIndep&gt; if a numerator expression had been name giving or D_&lt;nameDep&gt;_&lt;nameIndep&gt; if a denominator expression had been name giving.<br />
 The idea of reusing expressions is to present the expression in all details, when the very term is rendered, which was name giving to the expression. Consequently, the name is not returned (i.e. * <em>pName</em> is set to NULL) if the triple <em>idxDependent</em>, <em>idxIndependent</em> and <em>isNumerator</em> designates the name giving term of the solution.<br />
 The same expression should be referenced by name at all other locations, where it appears and hence, the name is returned. </td></tr>
    <tr><td class="paramname">ppExpression</td><td>The pointer to the denormalized expression is placed in * <em>ppExpression</em>. This expression has a normalized sign, i.e. the term of highest power in s has a positive numeric factor. The sign of the actual result is returned as * <em>pIsExpressionNegated</em>. </td></tr>
    <tr><td class="paramname">pIsExpressionNegated</td><td>If * <em>pIsExpressionNegated</em> is true then the expression ** <em>ppExpression</em> needs to be multiplied by -1 prior to further processing. </td></tr>
    <tr><td class="paramname">idxDependent</td><td>The index of the dependent quantity. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent quantity. </td></tr>
    <tr><td class="paramname">isNumerator</td><td>Pass <em>true</em> if the numerator expression is requested and <em>false</em> if the denominator is requested. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21747563cf45461c69c1bf6b5f36f3d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> printSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *const&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>asOctaveCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>printMargin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the solution into a stream in a human readable form. </p><dl class="section return"><dt>Returns</dt><dd>The result representation uses math operations, which can overflow. The presented result is valid only if this function returns <em>true</em>. A specific error message has been written to the log if <em>false</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to be printed. The object is the result of a successful call of <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int idxResult). </td></tr>
    <tr><td class="paramname">stream</td><td>The stream (as provided by the stdio lib) to write to. </td></tr>
    <tr><td class="paramname">asOctaveCode</td><td>The solution is printed either in human readable or as Octave script code. </td></tr>
    <tr><td class="paramname">printMargin</td><td>Line wrapping takes place when the margin is exceeded but the currently printed addend of the expression is still not completed. Checking the margin only after completing an addend means that the printed lines can become significantly longer than the margin says. So take a rather small value for the margin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa78b19bd78eeec5514a5cfb92f0d9398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frq_initModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLogger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module at application startup. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLogger</td><td>This module will use the passed logger object for all reporting during application life time. It must be a real object, LOG_HANDLE_TO_EMPTY_LOGGER_OBJECT is not permitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Do not forget to call the counterpart at application end. </dd>
<dd>
This module depends on the other module log_logger. It needs to be initialized after this other module. </dd>
<dd>
Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="frq__freq_domain_solution_8c.html#a0472bee087281ba40c57294aa3cc08d3">frq_shutdownModule()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0472bee087281ba40c57294aa3cc08d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frq_shutdownModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do all cleanup after use of the module, which is required to avoid memory leaks, orphaned handles, etc. </p>

</div>
</div>
<a class="anchor" id="a7badefe4e527d428b779b657ca3ee489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> frq_createFreqDomainSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> **const&#160;</td>
          <td class="paramname"><em>ppFrqDomSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> *const&#160;</td>
          <td class="paramname"><em>pAlgebraicSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>idxResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an object that a user defined result. The user defined result is a set of complex expressions, that describe the solution for a sub-set of unknowns of the LES and/or user defined voltages in the frequency domain. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if a valid object could be created, <em>false</em> otherwise. An error report has been written to the global application log if <em>false</em> should be returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppFrqDomSolution</td><td>A pointer to the new object is returned in * <em>pFrqDomSolution</em>. Some memory has been allocated on the heap; therefore the object needs to be deleted again after usage.<br />
 In case of an error a null object, FRQ_NULL_SOLUTION, is returned. </td></tr>
    <tr><td class="paramname">pAlgebraicSolution</td><td>The frequency domain solution is derived from an algebraic solution as figured out by the symbolic solver. Please, refer to boolean sol_createSolution(log_hLogger_t, const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> ** const, <a class="el" href="structles__linear_equation_system__t.html">les_linearEquationSystem_t</a> * const). This object contains a solution for all unknowns of the LES and for all user-defined voltages. </td></tr>
    <tr><td class="paramname">idxResult</td><td>The index of the user defined result, the solution is requested for. If a negative value is passed then a full result for all unknowns of the LES and all user defined voltages is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void frq_deleteFreqDomainSolution(frq_freqDomainSolution_t * const) </dd></dl>

</div>
</div>
<a class="anchor" id="a51362b03bae7fc0508ddc6f78e6ee813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a>* frq_cloneByReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request another reference to an existing object. The new reference is counted internally for later and safe control of the delete operation.<br />
 Any requested reference needs to be freed with frq_deleteFreqDomainSolution after use. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution() </dd>
<dd>
<a class="el" href="frq__freq_domain_solution_8c.html#a5bb94ced2700d2ce1416b0f72914fce4">frq_deleteFreqDomainSolution(const frq_freqDomainSolution_t * const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8b7fa0e60d6c5f1cabcbf7ad1ec2ad8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a>* frq_cloneByConstReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pExistingObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request another reference to an existing constant object. The new reference is counted internally for later and safe control of the delete operation.<br />
 Any requested reference needs to be freed with frq_deleteFreqDomainSolution after use. </p><dl class="section return"><dt>Returns</dt><dd>A read-only copy of the passed pointer <em>pExistingObj</em> is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pExistingObj</td><td>Pointer to the (read-only) object to be cloned by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution() </dd>
<dd>
<a class="el" href="frq__freq_domain_solution_8c.html#a5bb94ced2700d2ce1416b0f72914fce4">frq_deleteFreqDomainSolution(const frq_freqDomainSolution_t * const)</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The method is a kind of work around the somewhat unsatisfying concept of const data in C. Semantically, we make a copy of a never changed object to provide read access to another client. Actually this requires a write operation on the reference counter. A second problem is the deletion of such a copy; eventually it needs to call the free operation, which is not permitted just like that for const objects. We circumvent these problems by using explicit casts from const to modifiable. To keep these ugly operations local, we hide them in this function's and the destructor's implementation. Outside the copy operator the returned object can safely be used as read-only.<br />
 Actually, the operation of this function is exactly identical to its non constant counterpart. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb94ced2700d2ce1416b0f72914fce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frq_deleteFreqDomainSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pConstFreqDomainSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a reference to an existing object after use. If there are no references left then the object itself is deleted, all memory is freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pConstFreqDomainSolution</td><td>Pointer to the object to be deleted. No action if this is the NULL pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution(unsigned int, unsigned int, unsigned int) </dd>
<dd>
<a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_cloneByReference(<a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Regardless of the destructive operation the object is declared read-only in order to support deletion of read-only copies of references to existing objects. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed36d443d483179212c72914eaed81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* frq_getNameOfIndependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxIndependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of an independent quantity, i.e. an input quantity all the solutions offered by this object dependent on. </p><dl class="section return"><dt>Returns</dt><dd>Get the name as a read-only string. The returned character pointer points into the solution object and is valid as long as the solution object itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. </td></tr>
    <tr><td class="paramname">idxIndependent</td><td>The index of the independent, which is either 0 or identical to the index of a known in the LES. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31e3f7c9f0658fe36cd9267a1b644a94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* frq_getNameOfDependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDependent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a dependent quantity, i.e. a quantity the solution object offers a solution for. </p><dl class="section return"><dt>Returns</dt><dd>Get the name as a read-only string. The returned character pointer points into the solution object and is valid as long as the solution object itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the solution object. </td></tr>
    <tr><td class="paramname">idxDependent</td><td>The index of the dependent, which is identical to the index of the solutions held in this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ee8ebc66f1330fe481a6c32fc6fae79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void frq_logFreqDomainSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#af0f5518e5bd201b7e1f52e0702131c0e">log_hLogger_t</a>&#160;</td>
          <td class="paramname"><em>hLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log__logger_8h.html#a2d9e36e98870252e25ccbf4f033342c9">log_logLevel_t</a>&#160;</td>
          <td class="paramname"><em>logLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the solution of the system in the frequency domain to the application log. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to be printed. The object is the result of a successful call of <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int idxResult). </td></tr>
    <tr><td class="paramname">hLog</td><td>The handle of a logger to be used for reporting. </td></tr>
    <tr><td class="paramname">logLevel</td><td>The log level at which the output becomes visible. No output is created if the logger object in use has a higher level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6bd6c2c81e26c6f3149e4a36fc2deed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> frq_exportAsMCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *const&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> *const&#160;</td>
          <td class="paramname"><em>pMScript</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export the frequency domain solution as Octave M code. </p><dl class="section return"><dt>Returns</dt><dd>Rendering the solution as an M function can fail because of arithmetic overflows. If no problem appears then <em>true</em> is returned, <em>false</em> otherwise. The generated M code should not be used if the function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>The pointer to the object representing the solution to be printed. The object is the result of a successful call of <a class="el" href="structfrq__freq_domain_solution__t.html">frq_freqDomainSolution_t</a> *frq_createFreqDomainSolution(const <a class="el" href="structsol__solution__t.html">sol_solution_t</a> * const, unsigned int idxResult). </td></tr>
    <tr><td class="paramname">pMScript</td><td>The pointer to an M script object. The generated M code is written into this M script. The object is the result of a successful call of boolean msc_createMScript(<a class="el" href="structmsc__m_script__t.html">msc_mScript_t</a> ** const, const char * const, const char * const, const char * const). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8298fcfb537a7f39dcc014d2590e4792.html">linNet</a></li><li class="navelem"><a class="el" href="frq__freq_domain_solution_8c.html">frq_freqDomainSolution.c</a></li>
    <li class="footer">Generated on Tue Dec 30 2014 22:37:10 for linNet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
