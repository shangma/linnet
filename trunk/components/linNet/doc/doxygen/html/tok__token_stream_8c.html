<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>linNet: tok_tokenStream.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="linnet_small.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">linNet
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">linNet - The Software for symbolic Analysis of linear Electronic Circuits</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tok__token_stream_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tok_tokenStream.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="smalloc_8h_source.html">smalloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="snprintf_8h_source.html">snprintf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fio__fifo_char_8h_source.html">fio_fifoChar.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tok__token_stream_8h_source.html">tok_tokenStream.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1e9f684844ecce1e50e6f2157fbb5b25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a1e9f684844ecce1e50e6f2157fbb5b25">USE_LOCAL_BSEARCH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a1e9f684844ecce1e50e6f2157fbb5b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7aea2dbec1de0ae89132ad755ee362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3c7aea2dbec1de0ae89132ad755ee362">BSEARCH</a>&#160;&#160;&#160;bsearch</td></tr>
<tr class="separator:a3c7aea2dbec1de0ae89132ad755ee362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e67e9429d48a2ba8f833ee3b1dceb5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a4e67e9429d48a2ba8f833ee3b1dceb5d">EOL</a>&#160;&#160;&#160;((signed int)'\n')</td></tr>
<tr class="separator:a4e67e9429d48a2ba8f833ee3b1dceb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a3c26365e31993e9393ad1274b614"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a8b9a3c26365e31993e9393ad1274b614">NUM_LITERAL_TO_STR</a>(num)&#160;&#160;&#160;<a class="el" href="tok__token_stream_8c.html#ab72fc37171e27764d40da7afb4944474">INTERNAL_TO_STR</a>(num)</td></tr>
<tr class="separator:a8b9a3c26365e31993e9393ad1274b614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72fc37171e27764d40da7afb4944474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ab72fc37171e27764d40da7afb4944474">INTERNAL_TO_STR</a>(num)&#160;&#160;&#160;#num</td></tr>
<tr class="separator:ab72fc37171e27764d40da7afb4944474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cd85fd426a62b06fe7c1a4e093f6cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a31cd85fd426a62b06fe7c1a4e093f6cf">ERR_MSG_FSTR</a>&#160;&#160;&#160;&quot;Stream error in C stdio library, error number %d&quot;</td></tr>
<tr class="separator:a31cd85fd426a62b06fe7c1a4e093f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a18f09d3bb5a5f03a55546e38f8efd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7a18f09d3bb5a5f03a55546e38f8efd8">ERR_MSG</a>&#160;&#160;&#160;&quot;End of file in string literal beginning on line %u&quot;</td></tr>
<tr class="separator:a7a18f09d3bb5a5f03a55546e38f8efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c13e923567aefa55c9acb5b743f569f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a8c13e923567aefa55c9acb5b743f569f">MAX_LEN_NUMERAL</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a8c13e923567aefa55c9acb5b743f569f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d24b8f1d393167bac4a6adb8b399b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a254d24b8f1d393167bac4a6adb8b399b">INC_IDX</a></td></tr>
<tr class="separator:a254d24b8f1d393167bac4a6adb8b399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a18f09d3bb5a5f03a55546e38f8efd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7a18f09d3bb5a5f03a55546e38f8efd8">ERR_MSG</a>&#160;&#160;&#160;&quot;End of file in comment beginning on line %u&quot;</td></tr>
<tr class="separator:a7a18f09d3bb5a5f03a55546e38f8efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37db7dd9eb6918b2df172765cb3ef2be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a37db7dd9eb6918b2df172765cb3ef2be">ERR_MSG_FMT_STR</a>&#160;&#160;&#160;&quot;Can't open input file %s (errno: %d, %s)&quot;</td></tr>
<tr class="separator:a37db7dd9eb6918b2df172765cb3ef2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1fff2476924649765d90a17ecc9507ed"><td class="memItemLeft" align="right" valign="top">typedef struct syntaxOptions_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a1fff2476924649765d90a17ecc9507ed">syntaxOptions_t</a></td></tr>
<tr class="separator:a1fff2476924649765d90a17ecc9507ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492db6d845865f86df79ccc633dacf78"><td class="memItemLeft" align="right" valign="top">typedef struct tok_tokenStream_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a></td></tr>
<tr class="separator:a492db6d845865f86df79ccc633dacf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fda7fa87f6d3f3c61f5d54f4afa044b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a0fda7fa87f6d3f3c61f5d54f4afa044b">boolOption</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> option)</td></tr>
<tr class="separator:a0fda7fa87f6d3f3c61f5d54f4afa044b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae242f7ebe0360f20b15dac07165ee576"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ae242f7ebe0360f20b15dac07165ee576">optionEscapeChar</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:ae242f7ebe0360f20b15dac07165ee576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c7726c14a72f7c1048c0404d543f3f"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#aa6c7726c14a72f7c1048c0404d543f3f">optionStringQuote</a> (const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:aa6c7726c14a72f7c1048c0404d543f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f37979bbd27dcec7524afa770c1076f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2f37979bbd27dcec7524afa770c1076f">isodigit</a> (signed int c)</td></tr>
<tr class="separator:a2f37979bbd27dcec7524afa770c1076f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfae0bf07f081b38d08a4cb5448ad9d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#acfae0bf07f081b38d08a4cb5448ad9d4">iswhitespace</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, signed int c)</td></tr>
<tr class="separator:acfae0bf07f081b38d08a4cb5448ad9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3605c123453ecc8207a154a852c26c3c"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3605c123453ecc8207a154a852c26c3c">readCharFromStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:a3605c123453ecc8207a154a852c26c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df334147a2a0592e8c723a2bf4225ef"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a9df334147a2a0592e8c723a2bf4225ef">peekChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:a9df334147a2a0592e8c723a2bf4225ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929f7973517ba1f7451526a161e6532d"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a929f7973517ba1f7451526a161e6532d">nextRawChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:a929f7973517ba1f7451526a161e6532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d5260ee975383a18be95b1a99d420"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:a998d5260ee975383a18be95b1a99d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc83e19d32a62b4e289da5d923239a76"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#afc83e19d32a62b4e289da5d923239a76">currentChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:afc83e19d32a62b4e289da5d923239a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b31f47c98820c739302e54a801fe307"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a3b31f47c98820c739302e54a801fe307">readEscapedChar</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:a3b31f47c98820c739302e54a801fe307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af315bc631cedacf4a366e4b3d7912b43"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af315bc631cedacf4a366e4b3d7912b43">readStringLiteral</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:af315bc631cedacf4a366e4b3d7912b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e51c2a5ec8a56f773b37c3d3a147a7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af2e51c2a5ec8a56f773b37c3d3a147a7">readString</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:af2e51c2a5ec8a56f773b37c3d3a147a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f1e453a6496c5a30c076ff51be197"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a836f1e453a6496c5a30c076ff51be197">readNumeral</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a836f1e453a6496c5a30c076ff51be197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f36c5c8a8c369f4eeaf833c9f1f877"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ac2f36c5c8a8c369f4eeaf833c9f1f877">cmpTokenWithToken</a> (const void *p1, const void *p2)</td></tr>
<tr class="separator:ac2f36c5c8a8c369f4eeaf833c9f1f877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb956df17a0a03d2c132967768bc0b"><td class="memItemLeft" align="right" valign="top">static signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#ae0fb956df17a0a03d2c132967768bc0b">cmpTokenWithKey</a> (const void *pKey, const void *pElem)</td></tr>
<tr class="separator:ae0fb956df17a0a03d2c132967768bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e836797c4eb01f33bac446a9fa1024f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2e836797c4eb01f33bac446a9fa1024f">readIdentifier</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a2e836797c4eb01f33bac446a9fa1024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7663828c42ee81da90dd53672e4ac9fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a7663828c42ee81da90dd53672e4ac9fb">readCharacterConstant</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a7663828c42ee81da90dd53672e4ac9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfa604448671e422faadb84a21173d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#afbfa604448671e422faadb84a21173d9">readCustomSymbol</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:afbfa604448671e422faadb84a21173d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50acad930e5c64ed791a86e0dfea2be3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a50acad930e5c64ed791a86e0dfea2be3">readComment</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a50acad930e5c64ed791a86e0dfea2be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4669f501bd99188c558711c333b64964"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a4669f501bd99188c558711c333b64964">createTokenDescriptorTable</a> (<a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const pTokenStream, const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const pCustomTokenDefinition)</td></tr>
<tr class="separator:a4669f501bd99188c558711c333b64964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c0afab55aa777b30bc9ed2dec78895"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a47c0afab55aa777b30bc9ed2dec78895">deleteTokenDescriptorTable</a> (<a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const pTokenStream)</td></tr>
<tr class="separator:a47c0afab55aa777b30bc9ed2dec78895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff0f873238e261cf7f90cff1d02c037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#abff0f873238e261cf7f90cff1d02c037">tok_createTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const phTokenStream, char **const pErrorString, const char *const fileName, <a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a> hStream, const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a> customFctGetChar, const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const pCustomTokenDefinition)</td></tr>
<tr class="separator:abff0f873238e261cf7f90cff1d02c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af885a6c23c60d867f2b1848287b422aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#af885a6c23c60d867f2b1848287b422aa">tok_deleteTokenStream</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTokenStream)</td></tr>
<tr class="separator:af885a6c23c60d867f2b1848287b422aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a0a9c8c50295303866a2ac6752fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#aaa9a0a9c8c50295303866a2ac6752fdb">tok_setBoolOption</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a> option, <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> value)</td></tr>
<tr class="separator:aaa9a0a9c8c50295303866a2ac6752fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebbbd6e89026ec97adecd5e2ca296c2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a5ebbbd6e89026ec97adecd5e2ca296c2">tok_getErrorMsg</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:a5ebbbd6e89026ec97adecd5e2ca296c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16729b7f12f3a293663c6039b6d3979a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, const char **const pErrMsg)</td></tr>
<tr class="separator:a16729b7f12f3a293663c6039b6d3979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf05149020c59eac572e33b614034a1d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#abf05149020c59eac572e33b614034a1d">tok_getLine</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream)</td></tr>
<tr class="separator:abf05149020c59eac572e33b614034a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0f70b3c401fedd8730c15699392db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a2d0f70b3c401fedd8730c15699392db1">tok_fprintfToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, FILE *hStream, const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a2d0f70b3c401fedd8730c15699392db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6265f294842ee4d9e2c4fa2909e47a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tok__token_stream_8c.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken</a> (<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> hTStream, <a class="el" href="structtok__token__t.html">tok_token_t</a> *const pToken)</td></tr>
<tr class="separator:a6265f294842ee4d9e2c4fa2909e47a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module implements a token scanner for lexical symbols as used in the language C and many other languages. The input is parsed and returned to the client as a sequence of tokens.<br />
 The syntax definitions is somewhat open to configuration. Particular single characters or sequences of such can be defined to become named tokens. This way application dependent keywords and operators can be defined. Some syntax elements are hard coded and can't be re-defined, examples are number literals or identifiers.<br />
 The hard coded built-in syntax elements have priority over the client configured tokens. This means the latter cannot begin with a sequence of characters that resembles a built-in element, followed by some other characters, which would make them basically distinguishable: For example abc++cba is not supported as a user configured symbol. The scanner would first recognize an identifier abc and then fail to recognize the rest. Same for 'q, "xx or 23a, which are conflicting with character constants (beginning with
'), string literals (beginning with ") and numerals (beginning with a digit). ++abc would however be a valid custom symbol.<br />
 Binary literals are an option (%1001) and suffix multipliers are an option (3.45k) but for floating point numerals only.<br />
 String constants can be enclosed in single or double quotes. However, if single quotes are configured, then no C like character constants are recognized - they would be returned as strings of length one.<br />
 The end of line character can be handled as (ignored) white space or as recognized and returned token.<br />
 Comments can be enclosed in a pair of tags or they have a starting tag and end in front of the next end of line character. All three needed tags can be configured.<br />
 As long as no syntax error is found the scanner always returns a token. If it cannot match an input character to any of the more complex token types it'll return the character itself as token, i.e. the token type is set to the character code. This design decision has been taken because most parsers have to handle a lot of single character tokens like parenthesis and these are implicitly defined.</p>
<p>Copyright (C) 1992-2014 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1e9f684844ecce1e50e6f2157fbb5b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USE_LOCAL_BSEARCH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some compiler environments do not know the binary search routine. Then define the next symbol to be 1 and compile a local implementation. </p>

</div>
</div>
<a class="anchor" id="a3c7aea2dbec1de0ae89132ad755ee362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BSEARCH&#160;&#160;&#160;bsearch</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e67e9429d48a2ba8f833ee3b1dceb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EOL&#160;&#160;&#160;((signed int)'\n')</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The end of line indicator. </p>

</div>
</div>
<a class="anchor" id="a8b9a3c26365e31993e9393ad1274b614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_LITERAL_TO_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="tok__token_stream_8c.html#ab72fc37171e27764d40da7afb4944474">INTERNAL_TO_STR</a>(num)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a constant number as string literal, e.g. for static, compile time status messages. </p>

</div>
</div>
<a class="anchor" id="ab72fc37171e27764d40da7afb4944474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERNAL_TO_STR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num</td><td>)</td>
          <td>&#160;&#160;&#160;#num</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31cd85fd426a62b06fe7c1a4e093f6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG_FSTR&#160;&#160;&#160;&quot;Stream error in C stdio library, error number %d&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a18f09d3bb5a5f03a55546e38f8efd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG&#160;&#160;&#160;&quot;End of file in string literal beginning on line %u&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c13e923567aefa55c9acb5b743f569f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_LEN_NUMERAL&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a254d24b8f1d393167bac4a6adb8b399b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INC_IDX</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{   <span class="keywordflow">if</span>(idx &lt; <a class="code" href="tok__token_stream_8c.html#a8c13e923567aefa55c9acb5b743f569f">MAX_LEN_NUMERAL</a>)                                                       \</div>
<div class="line">                ++ idx;                                                                     \</div>
<div class="line">            else                                                                            \</div>
<div class="line">            {                                                                               \</div>
<div class="line">                hTStream-&gt;error = <span class="keyword">true</span>;                                                     \</div>
<div class="line">                free((<span class="keywordtype">char</span>*)hTStream-&gt;errorMsg);                                            \</div>
<div class="line">                hTStream-&gt;errorMsg = <a class="code" href="smalloc_8h.html#a549bfea173bfee7c36649d552559d826">stralloccpy</a>(<span class="stringliteral">&quot;Numeral is too long. Only up to &quot;</span>         \</div>
<div class="line">                                                 <a class="code" href="tok__token_stream_8c.html#a8b9a3c26365e31993e9393ad1274b614">NUM_LITERAL_TO_STR</a>(<a class="code" href="tok__token_stream_8c.html#a8c13e923567aefa55c9acb5b743f569f">MAX_LEN_NUMERAL</a>)        \</div>
<div class="line">                                                 <span class="stringliteral">&quot; characters are allowed&quot;</span>                  \</div>
<div class="line">                                                );                                          \</div>
<div class="line">            }                                                                               \</div>
<div class="line">        } <span class="comment">/* End of macro INC_IDX */</span></div>
<div class="ttc" id="tok__token_stream_8c_html_a8b9a3c26365e31993e9393ad1274b614"><div class="ttname"><a href="tok__token_stream_8c.html#a8b9a3c26365e31993e9393ad1274b614">NUM_LITERAL_TO_STR</a></div><div class="ttdeci">#define NUM_LITERAL_TO_STR(num)</div><div class="ttdef"><b>Definition:</b> tok_tokenStream.c:120</div></div>
<div class="ttc" id="smalloc_8h_html_a549bfea173bfee7c36649d552559d826"><div class="ttname"><a href="smalloc_8h.html#a549bfea173bfee7c36649d552559d826">stralloccpy</a></div><div class="ttdeci">static char * stralloccpy(const char *const str)</div><div class="ttdef"><b>Definition:</b> smalloc.h:102</div></div>
<div class="ttc" id="tok__token_stream_8c_html_a8c13e923567aefa55c9acb5b743f569f"><div class="ttname"><a href="tok__token_stream_8c.html#a8c13e923567aefa55c9acb5b743f569f">MAX_LEN_NUMERAL</a></div><div class="ttdeci">#define MAX_LEN_NUMERAL</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7a18f09d3bb5a5f03a55546e38f8efd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG&#160;&#160;&#160;&quot;End of file in comment beginning on line %u&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37db7dd9eb6918b2df172765cb3ef2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_MSG_FMT_STR&#160;&#160;&#160;&quot;Can't open input file %s (errno: %d, %s)&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1fff2476924649765d90a17ecc9507ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct syntaxOptions_t  syntaxOptions_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Some syntax construct of the tokenizer are optional, i.e. they can be switched on or off in order to customize the behavior. </p>

</div>
</div>
<a class="anchor" id="a492db6d845865f86df79ccc633dacf78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct tok_tokenStream_t  tok_tokenStream_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The token stream. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0fda7fa87f6d3f3c61f5d54f4afa044b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> boolOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a>&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a boolean option of the tokenizer. </p><dl class="section return"><dt>Returns</dt><dd>True or flase, the current setting of the option. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
    <tr><td class="paramname">option</td><td>Pass in, which Boolean option to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae242f7ebe0360f20b15dac07165ee576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int optionEscapeChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query option tok_optionEscapeCharIsDollarSign of the tokenizer. </p><dl class="section return"><dt>Returns</dt><dd>Get the selected escape character for character constants. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6c7726c14a72f7c1048c0404d543f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int optionStringQuote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query option tok_optionStringsUseSingleQuotes of the tokenizer. </p><dl class="section return"><dt>Returns</dt><dd>Get the selected quote character for string literals. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f37979bbd27dcec7524afa770c1076f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> isodigit </td>
          <td>(</td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decide, whether a character is an octal digit (0..7). </p><dl class="section return"><dt>Returns</dt><dd>Get the Boolean answer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfae0bf07f081b38d08a4cb5448ad9d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> iswhitespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decide, whether a character is white space. This function replaces the function isspace from the standard library because it treats the end of line differently: This is a token of particular interest by default. </p><dl class="section return"><dt>Returns</dt><dd>Get the Boolean answer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which is needed to access the option whether EOL is white space or not. </td></tr>
    <tr><td class="paramname">c</td><td>The character to test. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3605c123453ecc8207a154a852c26c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int readCharFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the next character from the actual stream, be it a stdio stream or an externally implemented custom stream. </p><dl class="section return"><dt>Returns</dt><dd>Get the next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9df334147a2a0592e8c723a2bf4225ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int peekChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Look at the next character in the stream. This is the character, the next call of signed int <a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar(tok_hTokenStream_t hTokenStream)</a> will return.<br />
 The call of this function does not iterate versus the future stream characters. If it is called repeatedly it'll always return the same character, which is the next one until nextChar is called. </p><dl class="section return"><dt>Returns</dt><dd>Get the preview on the next character in the stream. The character is however not consumed from the stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a929f7973517ba1f7451526a161e6532d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int nextRawChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the next character from the input stream. Normally the other function nextChar will be used by the scanner. This function is a bit more low level: It doesn't consider a line concatenation by the pair backslash+NL, but will return both characters as such in subsequent calls. </p><dl class="section return"><dt>Returns</dt><dd>The next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a998d5260ee975383a18be95b1a99d420"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int nextChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the next character from the input stream. Line concatenation by backslash+EOL is handled by the function, so it's transparent to the caller (besides an increment of the line number counter). Which means that a comment of type till-end-of-line can also benefit from line concatenation. </p><dl class="section return"><dt>Returns</dt><dd>The next character, which might be EOF to indicate the end of the parsing process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc83e19d32a62b4e289da5d923239a76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int currentChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the last recently read input character once again. The stream is not accessed at all. </p><dl class="section return"><dt>Returns</dt><dd>Get the same character as got in the preceding call of int <a class="el" href="tok__token_stream_8c.html#a998d5260ee975383a18be95b1a99d420">nextChar(tok_hTokenStream_t)</a> or EOF if the other function had not been called yet. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The token stream object to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b31f47c98820c739302e54a801fe307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int readEscapedChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the value of a character, that is defined by an expression starting with the backslash. The backslash was already consumed from the input stream by the calling function. </p><dl class="section return"><dt>Returns</dt><dd>The value of the character is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af315bc631cedacf4a366e4b3d7912b43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* readStringLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the contents of a string literal. This is everything in between a pair of (not escaped) quotes. The closing quote is not consumed from the input stream. Escape characters inside the string contents are resolved and no longer visible to the caller. </p><dl class="section return"><dt>Returns</dt><dd>The string contents are returned as malloc allocated string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>static char *readString(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="af2e51c2a5ec8a56f773b37c3d3a147a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a complete string constant. As in C, this is the concatenation of (double) quote enclosed string literals, if they are separated by white space only.<br />
 Attention: It is an option to see the EOL character not as white space but as a token. In this case string literal concatenation becomes rather useless as it is used in practice to break a lengthy string into different lines of source code. </p><dl class="section return"><dt>Returns</dt><dd>The string complete contents are returned as malloc allocated string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read string token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>static char *readStringLiteral(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a836f1e453a6496c5a30c076ff51be197"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readNumeral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the characters from the input stream that belong to and form a numeral. Binary, octal, decimal and hexadecimal literals are supported and floating point numbers.<br />
 Only positive numbers are considered. A possible sign would be a different, preceding token, to be handled by the client parser. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read number token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2f36c5c8a8c369f4eeaf833c9f1f877"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int cmpTokenWithToken </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparsion of two tokens in the token description table: Needed to sort the table initially. See qsort for more. </p><dl class="section return"><dt>Returns</dt><dd>&lt;0: The element pointed by <em>p1</em> goes before the element pointed by <em>p2</em>.<br />
 0: The element pointed by <em>p1</em> is equivalent to the element pointed by <em>p2</em>.<br />
&gt;0: The element pointed by <em>p1</em> goes after the element pointed by <em>p2</em>.<br />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Points to the first token description. </td></tr>
    <tr><td class="paramname">p2</td><td>Points to the second token description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is solely used by bsearch to look for a found identifier in the given table of known keywords. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fb956df17a0a03d2c132967768bc0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed int cmpTokenWithKey </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparsion of a token in the token description table with a key. The key is the symbol (a string) represented by the token. The comparison is needed to do a binary search for a given token in the table of client defined symbols. See bsearch for more. </p><dl class="section return"><dt>Returns</dt><dd>&lt;0: The element pointed by <em>pKey</em> goes before the element pointed by <em>pElem</em>.<br />
 0: The element pointed by <em>pKey</em> is equivalent to the element pointed by <em>pElem</em>.<br />
&gt;0: The element pointed by <em>pKey</em> goes after the element pointed by <em>pElem</em>.<br />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKey</td><td>Points to the key to match with <em>pElem</em>. * <em>pElem</em> will probably have a field, which is matched with the key value. </td></tr>
    <tr><td class="paramname">pElem</td><td>The element to be compared with the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is solely used by bsearch to look for a found identifier in the given table of known keywords. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e836797c4eb01f33bac446a9fa1024f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readIdentifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the characters from the input stream that belong to and form an identifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7663828c42ee81da90dd53672e4ac9fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readCharacterConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the characters from the input stream that belong to and form a character constant as defined in C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbfa604448671e422faadb84a21173d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readCustomSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current input character can't immediately be related to a lexical standard atom so try to match this and the subsequent input characters to a custom symbol. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read symbol is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50acad930e5c64ed791a86e0dfea2be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void readComment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The beginning of a comment had been recognized. This routine reads the comment contents until and including the comment end tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The token stream object, which has the character stream to read from.<br />
 A possible error indication is returned inside this object. </td></tr>
    <tr><td class="paramname">pToken</td><td>On entry, the token contains the just recognized comment starting token. This function does not change the token as the comment's contents are simply skipped and not returned to the caller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4669f501bd99188c558711c333b64964"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void createTokenDescriptorTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>pTokenStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const&#160;</td>
          <td class="paramname"><em>pCustomTokenDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create the token descriptor table in a newly created token stream object by making a deep copy of the client specified token definition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTokenStream</td><td>The handle of the token stream object. The operation is part of the creation of such an object. When calling this function, the object will be incomplete. Only the token definition related parts will be accessed. </td></tr>
    <tr><td class="paramname">pCustomTokenDefinition</td><td>The user provided specification of custom symbols and their token values by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47c0afab55aa777b30bc9ed2dec78895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void deleteTokenDescriptorTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8c.html#a492db6d845865f86df79ccc633dacf78">tok_tokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>pTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counterpart to createTokenDescriptorTable: The token descritor table is deleted, all malloc allocated strings are freed. The function is used from inside the destructor of a token stream object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTokenStream</td><td>The pointer to the currently deleted token stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abff0f873238e261cf7f90cff1d02c037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_createTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a> *const&#160;</td>
          <td class="paramname"><em>phTokenStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **const&#160;</td>
          <td class="paramname"><em>pErrorString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uniontok__h_stream__t.html">tok_hStream_t</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="tok__token_stream_8h.html#a71610e828ac97accc8bd63debb1dbb42">tok_customFctGetChar</a>&#160;</td>
          <td class="paramname"><em>customFctGetChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token_descriptor_table__t.html">tok_tokenDescriptorTable_t</a> *const&#160;</td>
          <td class="paramname"><em>pCustomTokenDefinition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A token stream object is created. It is associated with either a stdio stream or with any kind of custom character stream. The created object can be used to parse the input from that stream into a sequence of lexcical atoms or tokens. </p><dl class="section return"><dt>Returns</dt><dd>True, if the stream could be opened successfully, or false otherwise. The only other operation, which is permitted to be applied to the returned object, is tok_deleteTokenStream if the function returns false. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phTokenStream</td><td>The handle to the created object is placed into <em>phTokenStream</em>. </td></tr>
    <tr><td class="paramname">pErrorString</td><td>A pointer to a string variable owned by the caller. If an error appears, then a malloc allocated read-only string is placed into this variable. Normally NULL is returned in * <em>pErrorString</em>.<br />
 Caution: The caller is in charge to free the string after use. </td></tr>
    <tr><td class="paramname">fileName</td><td>The name of the file (or character stream), which is parsed. Mainly used for logging. Only, if hFile is NULL then it really needs to be the name of (and path to) an existing file. This file will then be opened for read access and be parsed.<br />
 If there's no reasonable name (e.g. in case of custom character input) then pass NULL or the empty string. </td></tr>
    <tr><td class="paramname">hStream</td><td>The parsed stream object. Either a stream from the stdio library or a custom stream of unknown type.<br />
 If parameter <em>customGetChar</em> is not NULL, then <em>hStream</em> is interpreted as handle of the custom stream. Otherwise it is interpreted as stdio stream (FILE*). In the latter case NULL may be passed: A file <em>fileName</em> will be opened as stdio stream and will be parsed then. </td></tr>
    <tr><td class="paramname">customFctGetChar</td><td>The pointer to a custom character input function, which reads a single character from a custom stream of type tok_hCharInputStream_t. Pass NULL if the stdio input should be used. </td></tr>
    <tr><td class="paramname">pCustomTokenDefinition</td><td>The customer provided extension of the internal symbol definitions. Basically a table associating symbols with token values. The tokenizer will look for the symbols in the input stream and return the associated token value if finds one. Additionally the symbols are specified, which mark beginning and end of comments.<br />
 Pass NULL if no custom symbols are needed.<br />
 The constructor makes a deep copy of the passed objects. All contained strings can be deleted after return from the constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af885a6c23c60d867f2b1848287b422aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_deleteTokenStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTokenStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a token stream object as created by tok_createTokenStream. A possibly open stdio stream is closed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTokenStream</td><td>The handle to the object to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa9a0a9c8c50295303866a2ac6752fdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_setBoolOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#a86a88d74d57151e6ef267b161fa1fa27">tok_syntaxOption_t</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an option of the tokenizer. Do this after object creation but prior to the first invocation of boolean <a class="el" href="tok__token_stream_8c.html#a6265f294842ee4d9e2c4fa2909e47a8f">tok_getNextToken(tok_hTokenStream_t, tok_token_t * const)</a>.<br />
 See enumeration <em>tok_syntaxOption_t</em> for the available options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">option</td><td>The selected option. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ebbbd6e89026ec97adecd5e2ca296c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tok_getErrorMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current, last recently set error message. </p><dl class="section return"><dt>Returns</dt><dd>Get a read-only string. The returned pointer is only valid until the next invocation of any method on the token stream object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> <a class="el" href="tok__token_stream_8c.html#a16729b7f12f3a293663c6039b6d3979a">tok_resetError(tok_hTokenStream_t, const char ** const)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16729b7f12f3a293663c6039b6d3979a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_resetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>pErrMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acknwledge an error. Most often, a parser will try to continue the process even after an error. If it reported an error from the tokenizer, it should explicitly reset the error in the token stream prior to calling tok_getNextToken the next time. Otherwise it looses the chance to see new errors. </p><dl class="section return"><dt>Returns</dt><dd>The cleared error status is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">pErrMsg</td><td>If not NULL the current (now cleared) error message is placed into * <em>pErrMsg</em>. The returned value is the pointer to a temporary read only string. It is valid only until the next call of whatever method of the token stream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>const char *tok_getErrorMsg(<a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="abf05149020c59eac572e33b614034a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tok_getLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current line number of the input stream. </p><dl class="section return"><dt>Returns</dt><dd>Get the line number. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d0f70b3c401fedd8730c15699392db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tok_fprintfToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug function (compiled only on demand, see <a class="el" href="tok__token_stream_8h.html#a45b048360c789ee610a202540443e606">TOK_COMPILE_FPRINTF_TOKEN</a>):<br />
 The type and value of a token is printed into a stdio stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object. </td></tr>
    <tr><td class="paramname">hStream</td><td>A handle to a stdio file with write access in text mode. </td></tr>
    <tr><td class="paramname">pToken</td><td>The token is passed in by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6265f294842ee4d9e2c4fa2909e47a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7c6368b321bd9acd0149b030bb8275ed">boolean</a> tok_getNextToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tok__token_stream_8h.html#ac6d0f0460027befdf25f37788ddc051f">tok_hTokenStream_t</a>&#160;</td>
          <td class="paramname"><em>hTStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtok__token__t.html">tok_token_t</a> *const&#160;</td>
          <td class="paramname"><em>pToken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main operation on a token stream: Read the next token (or lexical atom) from the input stream.<br />
 The end-of-file is always defined as a token. The client of this class will call this method in a loop until it gets the token EOF. Further calls are permitted but will always return EOF again. </p><dl class="section return"><dt>Returns</dt><dd>Recognizing tokens in read character sequences can fail. If the next characters in the stream do not form any defined token, then the function returns false. The client knows that there is a syntax error. It can request the error message by const char *tok_getErrorMsg(tok_hTokenStream_t). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTStream</td><td>The handle of the token stream object to read from. </td></tr>
    <tr><td class="paramname">pToken</td><td>The read token is placed into * <em>pToken</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_d0a8ca7c0fe7e177714a952ed8899c59.html">tokenStream</a></li><li class="navelem"><a class="el" href="tok__token_stream_8c.html">tok_tokenStream.c</a></li>
    <li class="footer">Generated on Tue Dec 30 2014 22:37:11 for linNet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
